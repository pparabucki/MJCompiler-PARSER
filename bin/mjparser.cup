package rs.ac.bg.etf.student.pp060115;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.visitors.*;
import rs.etf.pp1.symboltable.factory.SymbolTableFactory;
import rs.etf.pp1.symboltable.structure.SymbolDataStructure;
import java.lang.reflect.Field;
import java_cup.parser;
import rs.etf.pp1.mj.runtime.Code;


// ParserGenerator : javaCupMain
//	-destdir src\rs\ac\bg\etf\student\pp060115 -parser MJParser spec\mjparser.cup
// 	-destdir src\rs\ac\bg\etf\student\pp060115 -dump_states -parser MJParser spec\mjparser.cup

import java_cup.runtime.*;
import java.io.*;
import java.text.MessageFormat;

parser code {:
int  currentLevel = 0, numFuncDecl = 0, numFuncCalls = 0,numMainStatements=0;
	
	public static void main(String args[]) throws Exception {
       
        FileReader r = null;
        
        try {
            try {
                r = new FileReader(args[0]);
            }
            catch(Exception e) {
                System.err.println("Error while opening input file: " + args[0]);
                System.exit(1);
            }

            Yylex skener = new Yylex(r);
            MJParser p     = new MJParser(skener);

            // Make universe
            Tab.init();

            // Do parsing
            System.out.println("=====================SEMANTIC ANALYSIS=========================");
            Symbol s = p.parse();

            //print counts
            System.out.println("======================SYNTAX ANALYSIS=========================");
            p.action_obj.printAllCounts();

            //my Symbol Table
            MySymbolTableVisitor stv = new MySymbolTableVisitor();
            Tab.dump(stv);

            if (p.errorDetected)
              System.out.println("Input program contains errors!");
            else
              System.out.println("Parsing successfully finished!");

            try { 
            		File objFile = new File(args[1]);
                    // System.out.println("Upisujem u " + args[1]);
                    if(objFile.exists())
                   	  objFile.delete();
                   
               if ( !p.compileError && !Code.greska )                  	                    
                    Code.write(new FileOutputStream(objFile));
                
            }
            
            catch (Exception e) {
                System.err.println("Error while writing object file: " + args[1]);
                System.exit(1);
            }



        }
        finally {
            if (r != null)
                r.close();
        }
    }
	
	private boolean errorDetected = false;
	private boolean compileError = false;
	 
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  	 
  	public void nice_print(String format, Object... arguments){
      System.out.println(MessageFormat.format("Pretraga na liniji " + (((Integer) arguments[0])<10?"0":"") + "{0} ({1}) ," + format, arguments));
    }
    
   public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska na simbolu: " + cur_token, cur_token);
   }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error(" Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

     public void report_error(String message, Object info) {
        compileError = true;
        System.err.print(message);
        System.err.flush();
        if (info instanceof Symbol)
            System.err.println(" u liniji " + ((Symbol)info).left);
        else System.err.println("");
    }
     
    	
	 public void nice_report_error(String format, Object... arguments) {
        String message = MessageFormat.format(format, arguments);
        report_error(message, null);
        System.out.println("");
    }
    
    public Obj findClassObj(String name){
      Obj resultObj = null;
      for (Scope s = Tab.currentScope(); s != null; s = s.getOuter()) {
        if (s.getLocals() != null) {
          resultObj = s.getLocals().searchKey(name);
          if (resultObj != null)
            if(resultObj.getKind() == Obj.Meth)
              continue;
            else
              break;
        }
      }
      return (resultObj != null) ? resultObj : Tab.noObj;
    }
    
     public Obj tabInsert(int kind, String id, Struct type, int line) {
        if (Tab.currentScope().findSymbol(id) != null)
            nice_report_error("Greska na liniji {1} : ({0}) je vec deklarisano. ", id, line);
        return Tab.insert(kind, id, type);
    }

    public Obj insertMethod(Struct return_type, String id, int line) {
        // MethObj -> CurrentScope
        // Open new scope
        Obj obj = tabInsert(Obj.Meth, id, return_type, line);
        Tab.openScope();

        return obj;
    }
    
     /**
     * Flag that is set when we do inner classes, so every
     * variable from Scope is set to kind of Fld.
     */
    private boolean doingInnerClass = false;

    public void setDoingInnerClass(boolean f) {
        doingInnerClass = f;
    }
    public boolean getDoingInnerClass() {
        return doingInnerClass;
    }

    /**
     * Returns Obj.Fld if we are doing innerClass or Obj.Var in other cases
     *
     * @return Obj.kind = Fld | Var
     */
    public int varOrFld() {
        if (doingInnerClass) {
            return Obj.Fld;
        }
        else {
            return Obj.Var;
        }
    }
    /**
     * Execute action for method call, so we don't have to copy/paste actions
     * for parsing methods with&without parameters
     *
     * @param o Method object
     * @param oleft Line number for error reporting
     * @param functionCall If we call it as a function(returns value)
     */
    public void methodCallAction(Obj o, int oleft, boolean functionCall) {
        // Is object of a right type
        if (o.getKind() != Obj.Meth)
            nice_report_error("Error in line {0} expected method", oleft);

        // Function call should return value
        if (functionCall && o.getType() == Tab.noType)
            nice_report_error(
                "Error in line {0} procedure called as function"
                , oleft);

        // Calc relative address
        int dest_adr = o.getAdr() - Code.pc;

        // Generate code
        Code.put(Code.call);
        Code.put2(dest_adr);
        
        if (!functionCall && o.getType() != Tab.noType){
            // Result of call won't be used
        
       
        Code.put(Code.pop);
        
        }
    }
:}


scan with {:
	Symbol s = this.getScanner().next_token();
		//if (s != null && s.value != null) 
		//nice_print("Dodajem glupost ",s.getClass());
		//System.out.println("Linija " + s.left +" pronadjen simbol   (" + s.value.toString() + ") " + s.toString());
		
	return s;
:}

init with {:
	
	final int boole = 5;
	final int strin = 6;
	
	final Struct bool   = new Struct(boole);
	final Struct string = new Struct(strin);
		
	//Tab.init(); // Universe scope
	
	
	Tab.currentScope().addToLocals(new Obj(Obj.Type, "bool", bool));
	Tab.currentScope().addToLocals(new Obj(Obj.Type, "string", string));
	
	
:}

action code {:
	
	boolean returnFound = false;

  // Syntax Analysis counters
   private static int globalConstants = 0;
   private static int globalVars = 0;
   private static int globalArry = 0;
   private static int innerClass = 0;
   private static int innerMethod = 0;
   private static int numberOfMethodParameters = 0;
   private static int exprMain = 0;
   private static int funcInMain = 0;
   private static int defOfFunctionsInProgram = 0;
   private static int instantiateOfObject = 0;
   private static int definitionOfFields = 0;
   private static int numOfExtends = 0;
   private static short bul=0;
   private static boolean metoda = false;
   private static short argumenti = 0;
   
   public void printAllCounts() {
    System.out.println(MessageFormat.format(" {0}\tglobal constants", globalConstants));							//	R43		CONST
	System.out.println(MessageFormat.format(" {0}\tglobal vars", globalVars));										//	R43		INT , BOOL , STRING
	System.out.println(MessageFormat.format(" {0}\tglobal arrays", globalArry));									// 	R44		ARRAYS
	System.out.println(MessageFormat.format(" {0}\tdefinition of functions in program", defOfFunctionsInProgram));	// 	R45		NUMBER OF FUNCTION DEFINITIONS IN PROGRAM
	System.out.println(MessageFormat.format(" {0}\tinner class", innerClass));										//	R46
	System.out.println(MessageFormat.format(" {0}\texpression in main", exprMain));									// 	R47		STATEMENTS IN MAIN
	System.out.println(MessageFormat.format(" {0}\tfunctions in main", funcInMain));								//  R48		NUMBER OF CALL OF METHODS IN MAIN
	System.out.println(MessageFormat.format(" {0}\tinstantiate of object", instantiateOfObject));					//	R49		NUMBER OF INSTANTIATE OF OBJECTS
	System.out.println(MessageFormat.format(" {0}\tinner method", innerMethod));									//	R50		DEFINITION OF METHODS IN CLASS
	System.out.println(MessageFormat.format(" {0}\tclass fields", definitionOfFields));								//  R51		DECLARATION OF FIELDS
	//System.out.println(MessageFormat.format(" {0}\tnumberOfMethodParameters", numberOfMethodParameters));
	System.out.println(MessageFormat.format(" {0}\tnum of extends", numOfExtends));									//	R52		NUMBER OF EXTENDS
	
   }
   
   Integer boolVal = -1;
   Integer adresa = 0;
   
   Struct varType = Tab.noType;
   Struct methodType = Tab.noType;
   Struct innerClassType = null;
   
   
   String currentTypeName   = null;
   String currentTypeString = "";
   String currentString = "";
   String currentStringName = null;
   char[] str;
   Obj currentMethod=null;
   
   
   Object currVal		= null;
   Obj innerClassObj = null;
   Obj currType	= null;
   Obj currDes = null;
   Obj currClassField = null;
   Obj obj;
  
   boolean weAreInsideMain = false;
   boolean weAreInsideConstructor = false;
   boolean varDecIsGlobal = false;
   boolean returnExists = false;
   boolean doneObjectAccess = false;
   boolean instatieted = false;
   
   JumpAdrFixer jmpFixer = new JumpAdrFixer();
   LoopAdrFixer loopFixer = new LoopAdrFixer();
   Obj ca = new Obj(Obj.Con, "", Tab.intType);
   int a[] = new int[5];
:}

/*KLjUCNE RECI*/
terminal PROGRAM , PRINT , READ , IF , ELSE , BREAK , CLASS , EXTENDS , NEW , WHILE , DO , VOID , CONST , RETURN;

/*PROMENLjIVE - DATATYPE*/
terminal String 	IDENT;
terminal Integer	NUMBER;
terminal Character  CHARCONST;
terminal Boolean 	BOOLCONST;
terminal String 	STRCONST;

/*OPERATERI*/
terminal PLUS , MINUS , MULT , DEV , PERCENT , EQUALS ;
terminal EQUEQU , NOTEQU , GREATER , GREEQU , LESS , LESEQU;
terminal AND , OR;
terminal INCREM , DECREM;
terminal SEMICOL , COMMA , PERIOD;
terminal LPAREN , RPAREN , LBRACE , RBRACE , LSQPAREN , RSQPAREN;



non terminal Program 							;

non terminal DeclarationList, Declaration		;

non terminal MethodDeclList	, MethodDecl		;
non terminal MDLista							;

non terminal MDVar								;
non terminal MethodDeclUCL						;


non terminal ConstDecl							;

non terminal VarDecl							;
non terminal VDD ,dummy_terminal								;
non terminal VDDList		, VarDeclCL			;

non terminal ClassDecl							;
non terminal ClassIdent							;
non terminal ClassDeclM		, ClassDeclU		;

non terminal Struct Type						;
non terminal TypeDefList    , TypeDef			;


non terminal Integer CDD   						;

non terminal FormParsList   , FormPars			;

non terminal StatementList  , Statement			;

non terminal DesignatorList  ;
non terminal Obj Designator 	;
non terminal Struct Expr	, ExprListDef 		;
non terminal ExprRet							;
non terminal ExprListAP							;


non terminal ActPars							;
non terminal ActParsSt							;

non terminal Unmatched		, Matched	,machedInAction		;

non terminal Condition							;
non terminal CondTermOR		, CondFactAND		;
non terminal CondTerm							;
non terminal CondFact		, CondFactExp		;

non terminal ReadExprList						;

non terminal Relop								;

non terminal Struct Term								;


non terminal String Addop						;

non terminal Struct Factor		,FactorList				;


non terminal Integer MethodTypeName;
non terminal String Mulop			 			;

non terminal Obj ProgName					;

non terminal Obj ident_expr_list,object_access ;
non terminal Boolean bool_expr;
non terminal String string_expr;






// 	Program = "program" ident { ConstDecl | VarDecl | ClassDecl} "{" {MethodDecl} "}" .

Program 		::=   PROGRAM ProgName:p DeclarationList LBRACE MethodDeclList RBRACE 
{:
	Tab.chainLocalSymbols(p);
	// Static data size
	Code.dataSize = Tab.currentScope().getnVars();
	Tab.closeScope(); 
:}
;

ProgName ::= IDENT:pName
{:  
	RESULT = Tab.insert(Obj.Prog, pName, Tab.noType);
	Tab.openScope(); 
	parser.nice_print(" pronadjeno ime programa: {1}.", pNameleft , pName);
:}
;

DeclarationList ::=   DeclarationList Declaration
					|
					/* epsilon */
					;
					
Declaration		::=	  ConstDecl
					{: globalConstants++; :}
					| 
					{: varDecIsGlobal = true; :} 
					VarDecl 
					{: varDecIsGlobal = false; :}
					| ClassDecl
					;
					
MethodDeclList	::=   MethodDeclList MethodDecl {: defOfFunctionsInProgram++;:}
					|
					/* epsilon */
					;
					
//	ConstDecl = "const" Type ident "=" ( number | charConst | boolConst | strConst) 
//				    {"," ident"=" ( number | charConst | boolConst  | strConst)} ";".

ConstDecl		::=   CONST Type:t IDENT:id EQUALS CDD:v  
 					{:
                 		Obj o = parser.tabInsert(Obj.Con, id, t, tleft);
                 		
                 		o.setAdr( v );
                  		//parser.nice_print(" nadjeno Con {1} : " + currentTypeName.toString() +", " + o.getAdr() + ", " + o.getLevel() , idleft, id);
                  		
                  		
               		 :}
               		 SEMICOL
					|
					CONST Type:t IDENT:id EQUALS bool_expr:v  
 					{:
                 		Obj o = parser.tabInsert(Obj.Con, id, t, tleft);
                 		o.setAdr( boolVal );
                  		parser.nice_print(" nadjeno Con BOOL {1} : " + currentTypeName.toString() +", " + o.getAdr() + ", " + o.getLevel() , idleft, id);
                  		
                  		
               		 :}
               		 SEMICOL
					|
					CONST Type:t IDENT:id EQUALS string_expr:v  
 					{:
                 		Obj o = parser.tabInsert(Obj.Con, id, t, tleft);
                 		//parser.tabInsert(parser.varOrFld(), id, varType, idleft);
                 		
                 		//for(int i=0; i <v.length();i++){
                 		Code.put(Code.newarray);
                		Code.store(Tab.find(v));
                 		//}
                  		
               		 :}
               		 SEMICOL
					| 
					CONST	error  SEMICOL:l
					 {:
                  		parser.nice_report_error("Deklaracija konstante GRESKA. Oporavak do ;.",lleft);
                	:}
					;

CDD				::=  NUMBER:i
					{:
			          RESULT = i;
					  currVal = i;
					  currentTypeName = "int";
			        :}
					| CHARCONST:cc
			        {:
			          RESULT = (int)cc.charValue();
					  currVal = (int)cc.charValue();
					  currentTypeName = "char";
			        :}
					;

bool_expr		::=  BOOLCONST:bc
					{:
					  RESULT = bc.booleanValue();
					  if(bc.booleanValue() == true) boolVal = 1;
					  else boolVal = 0;
					  currentTypeName = "bool";
					:}
					;	

string_expr		::=  STRCONST:sc
					{:
					  RESULT = (String)sc.toString();
					  currentString = (String)sc.toString();
					  currentTypeName = "string";
					 
					:}
					;

// VarDecl = Type ident ["[" "]" ] {"," ident ["[" "]" ] } ";".

VarDecl 		::=   Type:t
					 {: varType = t; :}
					  VDDList SEMICOL
					| Type error SEMICOL:l
					 {:
               			 parser.nice_report_error("Deklaracija promenljivih GRESKA. Oporavak do ;.",lleft);
              		:}
					;

VDDList			::= VDDList COMMA VDD
					|
					VDD
					; 

VDD				::= IDENT:id
						{:
							//Obj o = parser.tabInsert(parser.varOrFld(), id, new Struct(varType.getKind(), varType), idleft);
							//parser.nice_print(" nadjeno Var {1} : " + currentTypeName.toString() +", " + o.getAdr() + ", " + o.getLevel() , idleft, id);
							parser.tabInsert(parser.varOrFld(), id, varType, idleft);
							if (varDecIsGlobal) {
								globalVars++;
							}
						:}
					|
					IDENT:id LSQPAREN RSQPAREN
						{:
							//Obj o = parser.tabInsert(parser.varOrFld(), id, new Struct(Struct.Array, varType), idleft);
							//parser.nice_print(" nadjeno Var {1} Array of : " + currentTypeName.toString() +", " + o.getAdr() + ", " + o.getLevel() , idleft, id);
							
							parser.tabInsert(parser.varOrFld(), id, new Struct(Struct.Array, varType), idleft);
							if (varDecIsGlobal) {
								globalArry++;
							}
						:}
					;



// ClassDecl = "class" ident ["extends" ident ] "{" {VarDecl | MethodDecl } "}".

ClassDecl		::= ClassDeclM | ClassDeclU;

ClassDeclM   	::=   CLASS IDENT:id EXTENDS IDENT:nasledjena 
					  LBRACE
					  {:
					  	if(Tab.find(nasledjena.toString())==Tab.noObj ){
				       		
				       			System.out.println("Klasa " + nasledjena.toString() + " nije definisana - te je nemoguce naslediti je." );
				       			RESULT = Tab.noObj;		
				       			Tab.openScope();		       			
				       		}else{
				       		
					    
					        
					        innerClassType = new Struct(Struct.Class);
					
					        RESULT        = parser.tabInsert(Obj.Type, id, innerClassType, idleft);
					        innerClassObj = (Obj) RESULT;
					        Tab.openScope();
							numOfExtends++;
					        parser.setDoingInnerClass(true);
					    }
				       		
					  :}
					  VarDeclCL 	
					  {:
					  		if(RESULT != Tab.noObj){
				      		((Obj) RESULT).getType().setMembers(Tab.currentScope().getLocals());
				       		System.out.println("Klasa "+ ((Obj) RESULT).getName() +" nasledjuje klasu " + nasledjena.toString()  );
				       		}
				      :} 
					  MethodDeclUCL 
					  {:
						     // Insert methods&fields inside obj
						     if(RESULT != Tab.noObj){ 
						     ((Obj) RESULT).getType().setMembers(Tab.currentScope().getLocals());
						
						     innerClass++;
							 }
						     // Clean up
						     Tab.closeScope();
						     parser.setDoingInnerClass(false);
						:}
					  RBRACE 
					 
					;

ClassDeclU   	::=   ClassIdent:o  
					  LBRACE
					  VarDeclCL 	
					  {:
				      		// Set field members of a inner class
				       		((Obj) o).getType().setMembers(Tab.currentScope().getLocals());
				      :} 
					  MethodDeclUCL 
					  {:
						     // Insert methods&fields inside obj
						        
						     ((Obj) o).getType().setMembers(Tab.currentScope().getLocals());
						
						     innerClass++;
						
						     // Clean up
						     Tab.closeScope();
						     parser.setDoingInnerClass(false);
						:}
					  RBRACE 
					  | ClassIdent:o LBRACE error RBRACE
					  {: parser.debug_message("Uspesan oporavak od greske pri dodeli vrednosti."); :}
					  | ClassIdent:o LBRACE error SEMICOL 
					  {: parser.debug_message("Uspesan oporavak od greske pri dodeli vrednosti."); :}
					;

ClassIdent		::=   CLASS IDENT:id
					    {:
					        
					        innerClassType = new Struct(Struct.Class);
					
					        RESULT        = parser.tabInsert(Obj.Type, id, innerClassType, idleft);
					        innerClassObj = (Obj) RESULT;
					        Tab.openScope();
					
					        parser.setDoingInnerClass(true);
					    :}
					    ;

VarDeclCL		::=   VarDeclCL VarDecl
					| 
					/* epsilon */
					;
					
MethodDeclUCL	::=   LBRACE
					  MDLista					
					  RBRACE
					  |
					  /* epsilon */
					  ;
					  
MDLista	::=   MDLista MethodDecl
					|
					/* epsilon */
					;

MethodDecl ::= MethodTypeName:exists LPAREN FormParsList RPAREN MDVar LBRACE
				{:
				if (exists==1){
					currentMethod.setAdr(Code.pc);
					if ("main".equals(currentMethod.getName())){
						Code.mainPc = currentMethod.getAdr();
					}
					Code.put(Code.enter);//enter instrukcija
					if(("main".equals(currentMethod.getName())))
					Code.put(currentMethod.getLevel());//u level polju cuvamo broj argumenata metode
					else{ Code.put(argumenti);// System.out.println("Stavio argumente "+argumenti);
					}
					Code.put(Tab.currentScope().getnVars());
				}
				:}
				StatementList RBRACE //Obj je method
				{:
				if (exists==1){
					if ( !returnFound && currentMethod.getType() != Tab.noType )
						parser.report_error(" Semanticka greska: u metodi " + currentMethod.getName() + " nedostaje return iskaz!", null);
				
					Code.put(Code.exit);//zavrsne instrukcije unutar metode
					Code.put(Code.return_);
					
					Tab.chainLocalSymbols(currentMethod);
					Tab.closeScope();
					
					returnFound = false;
					currentMethod = null;
					parser.currentLevel--;
				}
				:}
				|
				MethodTypeName LPAREN error:err RPAREN MDVar LBRACE StatementList RBRACE
				{:
					parser.report_error("Greska na liniji: " + errleft + " deklaracija formalnih parametara u funkciji nekorektna.", null);
				:}
				|
				MethodTypeName:method LPAREN FormParsList RPAREN error:err SEMICOL StatementList RBRACE
				{:
					parser.report_error("Greska pri definiciji lokalnih promenljiva kod metode do ;. Na liniji: " + errleft, null);
				:}
				 ;

MethodTypeName ::= Type:retType IDENT:methName
				{:
				Obj resultObj = null;
				Scope s = Tab.currentScope();
				
				if (s.getLocals() != null) resultObj = s.getLocals().searchKey(methName);	// provera da li postoji metoda s tim imenom
			
				Obj temp = (resultObj != null) ? resultObj : Tab.noObj;
				
				if ( temp!=Tab.noObj ) { 
					parser.report_error("Greska na liniji: "+ methNameleft + ", metoda: " + methName + " je vec deklarisana.",null);
					RESULT=0;
				}
				else {
					parser.numFuncDecl++;	//if( !methName.equals("main") ) 
					currentMethod = Tab.insert(Obj.Meth, methName, retType);
					parser.currentLevel++;
					Tab.openScope();
					RESULT=1;
				}
				:}
				|
				VOID IDENT:methName
				{:
				Obj resultObj = null;
				Scope s = Tab.currentScope();
				
				if (s.getLocals() != null) resultObj = s.getLocals().searchKey(methName);
			
				Obj temp = (resultObj != null) ? resultObj : Tab.noObj;
				
				if ( temp!=Tab.noObj ) { 
					parser.report_error("Greska na liniji: "+ methNameleft + ", metoda: " + methName + " je vec deklarisana.",null);
					RESULT=0;
				}
				else {
					parser.numFuncDecl++;	//if( !methName.equals("main") ) 
					currentMethod = Tab.insert(Obj.Meth, methName, Tab.noType);
					parser.currentLevel++;
					Tab.openScope();
					RESULT=1;
				}			
				:}
				;
					

					
// MethodDecl = (Type | "void") ident "(" [FormPars] ")" {VarDecl} "{" {Statement} "}".




FormParsList	::=   FormPars
					| 
					/* epsilon */
					; 
					
MDVar			::=   MDVar VarDecl
					| 
					/* epsilon */
					; 
					
StatementList	::=   StatementList Statement
					| 
					/* epsilon */
					; 

// Type = ident.

Type			::= IDENT :id
					{:
					    
						currentTypeString = id;
						
					    Obj newObj = Tab.find(id);
					    if(newObj!=null) currentTypeName = id;
					
					    if(newObj.getKind() == Obj.Meth){
					      newObj = parser.findClassObj(currentTypeName);
					      System.out.println("METODAAAA");
					    }
					
					    if(newObj.getKind() != Obj.Type){
					      parser.nice_report_error("{1} nije tip podatka!", idleft, id);
					      newObj = Tab.noObj;
					    }
					    RESULT = newObj.getType();
					  :}
					  ;

// FormPars = Type ident [ "[" "]" ] {"," Type ident [ "[" "]" ] }.

FormPars		::= TypeDef TypeDefList;

TypeDefList		::=   TypeDefList COMMA TypeDef
					| 
					/* epsilon */
					; 
					
TypeDef			::= Type:t IDENT:id
				   {:
				   		argumenti++;
				   		numberOfMethodParameters ++; 
				        Tab.insert(Obj.Var, id, t);
				   :} 
				   |
				   Type:t IDENT:id LSQPAREN RSQPAREN
					{:
						numberOfMethodParameters ++; 
					    Tab.insert(Obj.Var, id, new Struct(Struct.Array, t));
					:}
				   
				   ;


					
//Statement =  Designator ("=" Expr | "++" | "--" |  "(" [ActPars] ")" ) ";"
//			 | "if" "(" Condition ")" Statement ["else" Statement ]
//			 | "while" "(" Condition ")" Statement
//			 | "read" "(" Designator ")" ";"
//			 | "print" "(" Expr ["," number] ")" ";"
//			 | "break" ";"
//			 | "return" [Expr] ";"
//			 | "{" {Statement} "}"
//			 | "do" "{" {Statement} "}" "while" "(" Condition ")" ";".


Statement 		::= Matched 
					{:
						if (weAreInsideMain)
           					exprMain++;
					:} 
					| 
					Unmatched 
					{:
						if (weAreInsideMain)
           					exprMain++;
					:}
					;

Unmatched 		::=   IF LPAREN Condition RPAREN machedInAction
					ELSE Unmatched  
					{:
				        jmpFixer.fixCurAdrLevel(Code.pc);
				    :}
					| IF LPAREN Condition RPAREN Statement
					{:
				        jmpFixer.fixCurAdrLevel(Code.pc);
				    :}
					;
					

Matched  		::=   Designator:d {: if (weAreInsideMain) exprMain++; currDes=d; :} DesignatorList SEMICOL
				|
					Designator:dest INCREM SEMICOL	//dest je Obj
				{:
					if(currentMethod.getName().equals("main")) parser.numMainStatements++;
					
					if ( (dest.getKind() != Obj.Var) && (dest.getKind() != Obj.Elem) )	//dest.getType() != Tab.intType ||
						parser.report_error( "Greska na liniji: " + destleft + ": " + dest.getName() + " nije promenljiva." , null);
					else{
					
						Code.load(dest);
						Obj c = Tab.insert(Obj.Con, "", Tab.intType);
						c.setAdr(1);
						Code.load(c);
						Code.put(Code.add);
						Code.store(dest);
						
					}
				:}
				|
				Designator:dest DECREM SEMICOL
				{:
					if(currentMethod.getName().equals("main")) parser.numMainStatements++;
					
					if ( (dest.getKind() != Obj.Var) && (dest.getKind() != Obj.Elem) )	//dest.getType() != Tab.intType || 
						parser.report_error( "Greska na liniji: " + destleft + ": " + dest.getName() + " nije promenljiva." , null);
					else{
						Code.load(dest);
						Obj c = Tab.insert(Obj.Con, "", Tab.intType);
						c.setAdr(1);
						Code.load(c);
						Code.put(Code.sub);
						Code.store(dest);
					}
				:}
					
					| Designator:o  EQUALS Expr:t SEMICOL
					
					{:
					 if (weAreInsideMain) exprMain++; 
					 if (t == null)
			            System.out.println("t is null");
			         else if (o == null)
			            System.out.println("o is null");
			         else if (((Obj)o).getType() == null)
			            System.out.println("o.type is null");
			
			         // Check if assignable
			       	 if(bul==1){
			         	Code.store(o);
			         	bul=0;
			         	//System.out.println("Dodao bul");			         	
			         }
			         else{
			       		if (t.assignableTo(o.getType()) )
            				Code.store(o);
			        	 else{
			           	 parser.nice_report_error(
			            	  "Error in line {0} incompatibile types used in assignment"
			              	, oleft);
			         	}
					 }
			        // Check for constants on left side
			        if (((Obj)o).getKind() == Obj.Con) {
			            parser.nice_report_error(
			              "Id {0} is constant on left side of assignment, at line {1}"
			              , ((Obj)o).getName()
			              , oleft);
			        }
			
			        doneObjectAccess = false;
					:}
					
					| 
					IF LPAREN Condition RPAREN machedInAction
					
					 ELSE Matched   
					{:
				        jmpFixer.fixCurAdrLevel(Code.pc);
				    :}
					| Designator error SEMICOL
					|
					{:loopFixer.saveLoopTop(Code.pc);:} 
					WHILE LPAREN Condition	RPAREN	Matched
					{:
				        Code.put(Code.jmp);
				        Code.put2(loopFixer.popCurrentLoopTop() - (Code.pc - 1));// 1 = jmp op
				        //System.out.println("Relative address " + (whileTop - Code.pc));
				        jmpFixer.fixCurAdrLevel(Code.pc);
				    :}
					| READ LPAREN Designator:d RPAREN SEMICOL	
					{: 
					
							if (weAreInsideMain) funcInMain++;  
					
						if (d.getType() != Tab.intType && d.getType() != Tab.charType  && d.getType() != Tab.find("bool").getType() && d.getType() != Tab.find("string").getType())
					           parser.nice_report_error("Error in line {0} expr type must be int or char", dleft);
					    
					    
						    if(d.getType() == Tab.intType) {
		                    Code.put(Code.read);
		                } 
						else if(d.getType() == Tab.charType){
		                    Code.put(Code.bread);
		                }
						else if(d.getType() == Tab.find("bool").getType()){
		                    Code.put(Code.read);
		                }
						else if(d.getType() == Tab.find("string").getType()){
		                   for(int i=0;i<currentString.length();i++)
		                   	Code.put(Code.bread);
		                }
		            
		               currType = Tab.find(d.getName());
		               
		               if(currType!=null){
		            	
		            	
		            	            	  
					   	Code.store(d);
					  // System.out.println("USAO");
					   }
					 
				   
					:}
					| PRINT LPAREN Expr:t RPAREN SEMICOL
					{: 
							
							
							if (weAreInsideMain) funcInMain++; 
							
							if (t != Tab.intType && t != Tab.charType  && t != Tab.find("bool").getType() && t != Tab.find("string").getType())
					           parser.nice_report_error("Error in line {0} expr type must be int or char", tleft);
					       
					        if (t == Tab.intType) {
					            // width of printout
					            
					            Code.loadConst(5);
					            Code.put(Code.print);
					            
					        } else if( t == Tab.charType ) {
					            // width of printout
					            
					            Code.loadConst(1);					            
					            Code.put(Code.bprint);
					            
					        } else if(t == Tab.find("bool").getType()){
					        	//System.out.println("USAO U BOOL");
					        	Code.loadConst(1);
					        	Code.put(Code.bprint);
					        }
					            else if(t == Tab.find("string").getType()){
					        	//System.out.println("USAO U STRING "+ currentString  +" DUZINA = "+currentString.length());
					        	
	                 				Code.loadConst(1);
	                 				Code.put(Code.bprint);
	                 				
						    
					        	
					        }
					 :}
					| PRINT LPAREN Expr:t COMMA NUMBER:num RPAREN SEMICOL
					{: 
							int i = num.intValue();
							
							if (weAreInsideMain) funcInMain++; 
							
							if (t != Tab.intType && t != Tab.charType  && t != Tab.find("bool").getType() && t != Tab.find("string").getType())
					           parser.nice_report_error("Error in line {0} expr type must be int or char", tleft);
					       
					        if (t == Tab.intType) {
					            // width of printout
					            
					            Code.loadConst(i);
					            Code.put(Code.print);
					            
					        } else if( t == Tab.charType ) {
					            // width of printout
					            
					            Code.loadConst(i);					            
					            Code.put(Code.bprint);
					            
					        } else if(t == Tab.find("bool").getType()){
					        	//System.out.println("USAO U BOOL");
					        	Code.loadConst(i);	
					        	Code.put(Code.bprint);
					        }
					            else if(t == Tab.find("string").getType()){
					        	//System.out.println("USAO U STRING "+ currentString  +" DUZINA = "+currentString.length());
					        	
	                 				Code.loadConst(i);
	                 				Code.put(Code.bprint);
	                 				
						    
					        	
					        }
					 :}
					| BREAK SEMICOL
					| RETURN:dummy
					 {:
					   returnExists = true;
					 :} 
					   Expr:t	SEMICOL
       					{:
					if(currentMethod.getName().equals("main")) parser.numMainStatements++;
					
					returnFound = true;
					Struct currMethType = currentMethod.getType();
					
					if ( !currMethType.compatibleWith(t) ) {
						parser.report_error(" Greska na liniji: " + tleft + " tip izraza u return naredbi ne slaze se s tipom povratne vrednosti funkcije: " + currentMethod.getName(), null);
					}
					else {
						Code.put(Code.exit);
						Code.put(Code.return_);
					}
					:}
					|  LBRACE StatementList RBRACE SEMICOL
					|  LBRACE error RBRACE:l
					  {:
                  		parser.nice_report_error("Greska unutar definisanja izraza. Oporavak do }.",lleft);
                	  :}
					| DO LBRACE Matched RBRACE WHILE LPAREN Condition RPAREN SEMICOL
					;

machedInAction	::= Matched
				    {:
				        /* 3 = jmp.length + address_length */
				        jmpFixer.fixCurAdrLevel(Code.pc + 3);
				        Code.put(Code.jmp);
				
				        jmpFixer.newAdrLevel(Code.pc);
				        Code.put2(0);
				    :}
				    ;

DesignatorList	::=  LPAREN {:metoda=true;argumenti=0;:} ActParsSt:o RPAREN
					{:
						metoda=false;
				        if (weAreInsideMain) funcInMain++;
				        parser.methodCallAction(currDes, currDes.getAdr(), false);
				        // System.out.println("USAO U POZIV FUNKCIJE");
						//argumenti=0;
				        doneObjectAccess = false;
				    :}
					
					;
					
ActParsSt		::=   ActPars
					| 
					/* epsilon */
					; 
					
ReadExprList	::=	  COMMA NUMBER
					| 
					/* epsilon */
					; 
					
ExprRet			::=   Expr:t
				    {:
				    	System.out.println("T = "+t);
				    	System.out.println("Metoda = "+methodType);
				        if (!t.assignableTo(methodType)){
				            parser.nice_report_error(
				                "Error in line {0} type not compatible with method declaration"
				                , tleft);
				                }
				    :}
					 |
					    dummy_terminal:dummy
					    {:
					        if (methodType != Tab.noType)
					            parser.nice_report_error(
					                "Error in line {0} method must have return statement"
					                , dummyleft);
					    :}
					/* epsilon */
					;
					
dummy_terminal ::=
				    /* epsilon */
				    ;					
									
// ActPars = Expr {"," Expr }.

ActPars			::= Expr ExprListAP;

ExprListAP		::=   ExprListAP COMMA Expr
					| 
					/* epsilon */
					;

// Condition = CondTerm { "||" CondTerm }.

Condition		::= CondTerm CondTermOR;		

CondTermOR	::=       CondTermOR OR CondTerm
					| 
					/* epsilon */
					;

// CondTerm = CondFact { "&&" CondFact }.

CondTerm		::= CondFact CondFactAND;

CondFactAND		::=   CondFactAND AND CondFact
					| 
					/* epsilon */
					;

// CondFact = Expr [ Relop Expr ].

CondFact		::= Expr CondFactExp;

CondFactExp		::=   Relop Expr
					| 
					/* epsilon */
					;
					
// Expr = ["-"] Term {Addop Term}

Expr			::= ExprListDef:t {:RESULT = t; :};


					
ExprListDef		::=   ExprListDef:t1 Addop:s Term:t2
					  {:
					        if (s.equals("+"))
					            Code.put(Code.add);
					        else if (s.equals("-"))
					            Code.put(Code.sub);
					        RESULT = t1;
					   :}
					|
					Term:t
    				{: 
    				   				
    				RESULT = t; 
    				
    				:} 
					/* epsilon */
					;
					
// Term = Factor {Mulop Factor}

Term			::= FactorList:t 
				{:
					RESULT=t; 
				:};

FactorList 		::= FactorList:t1 Mulop:s Factor:t2
				 {:
				        if (s.equals("*"))
				            Code.put(Code.mul);
				        else if (s.equals("/"))
				            Code.put(Code.div);
				        else if(s.equals("%"))
				        	Code.put(Code.rem);
				        RESULT = t2;
				 :}
				|
				Factor:t {: RESULT = t; :}
				| 
				MINUS Factor:t
			    {:
			        Code.put(Code.neg);
			        RESULT = t;
			    :}
			    ;

					
//Factor = number | charConst | "(" Expr ")" | boolConst | strConst
//				  | "new" Type [ "[" Expr "]" ] 
//				  | Designator [ "(" [ActPars] ")" ]

Factor			::=   NUMBER:i
					 {:
					 	if(!metoda){
					        Obj c = new Obj(Obj.Con, "", Tab.intType);
					        c.setAdr(i.intValue());
					        Code.load(c);
					        RESULT = Tab.intType;
					       // System.out.println("nije metoda poziv parametara"+i.intValue());
					     }else{

					    	
						        ca.setAdr(i.intValue());
						        Code.load(ca);
						        RESULT = Tab.intType;
					     	//System.out.println("metoda poziv parametara"+i.intValue());   
					     	a[argumenti]=i;
					     	argumenti++;
					        }
					  :}
					| CHARCONST:c
					 {:
				        Obj o = new Obj(Obj.Con, "", Tab.charType);
				        o.setAdr(c.charValue());
				        Code.load(o);
				        RESULT = Tab.charType;
				    :}
					| LPAREN Expr:t RPAREN
					{:
					
					//System.out.println("USAO u"+t);
					Obj klass = Tab.find(currentTypeString);
					
					Obj constructor = klass.getType().getMembers().searchKey(currentTypeString);
					
				    if (constructor != null) {
					   parser.methodCallAction(constructor, tleft, true);
					}
									
					 RESULT=t; 
					 :}				
					
					
					|bool_expr:b	
					{: 	
						bul=1; 
						Obj o = new Obj(Obj.Con, "", Tab.intType);
					   	if(b.booleanValue()==false){
					     	//
					     	o.setAdr(48);
					     	Code.load(o);
					     }
						else{  
							//
							o.setAdr(49);
							Code.load(o);
					   }
						RESULT = Tab.find(currentTypeName).getType();
						//System.out.println("|AS"+currentTypeName);
					:}
					|string_expr:st	
					{:	
					
					System.out.println("SSTTRRIINNGG"+currentTypeName);
					
					:}
					|NEW Type:t LSQPAREN Expr:t1 RSQPAREN
				    {:
				    	//System.out.println("AAAAAA");
				        if (t1 != Tab.intType)
				            parser.nice_report_error("Error in line {0} length of array must be int", tleft);
				        Code.put(Code.newarray);
				        if (t == Tab.charType)
				            Code.put(0);
				          else
				            Code.put(1);
				           
				        RESULT = new Struct(Struct.Array, t);
				    :}
					| NEW Type:t
				        {:
				            // Use this as "this" if we call constructor
				            Code.put(Code.new_);
				            Code.put2(t.getNumberOfFields());
				        :}
				      LPAREN ActPars RPAREN
					    {:
					        // First: find class belonging to type
					        Obj klass = Tab.find(currentTypeString);
					
					        // Second: Find constructor
					        Obj constructor = klass.getType() /* Struct */
					 /* SymbolDataStructure */  .getMembers()
					 /* Obj                 */  .searchKey(currentTypeString);
					
					        // Third: If it exists, call it
					        if (constructor != null) {
					            parser.methodCallAction(constructor, tleft, /* functionCall = */ true);
					        }
					
					        RESULT = t;
					    :}
					|Designator:o 
					   {:
					   	
					   		if ( o.equals(Obj.Var)  
					            && o.equals(Obj.Elem)
					            && o.equals(Obj.Fld)
					            && o.equals(Obj.Con)) {
					
					            parser.nice_report_error(
					                "Error in line {0} expected type with value" , ((Obj) o)
					                );
					
					        }
						
					        // load first "this" param implicitly for all fields
					        // that have no loaded object
					        if (parser.getDoingInnerClass()
					                && o.equals(Obj.Fld)
					                && !doneObjectAccess) {
					            Obj _this_ = Tab.find("this");
					            Code.load(_this_);
					        }
					       
					       if(!o.getName().equalsIgnoreCase("funkcija")){ Code.load(o); }
					       else{ 
					       parser.methodCallAction(o, oleft, /* isFunctionCall = */ true);
					       System.out.println("ASDASDASD");
					       }
					        
					       	RESULT = o.getType();
					       	 definitionOfFields++;
					
					        doneObjectAccess = false;
					    :}
					|
					Designator:o LPAREN {:metoda=true; :} ActPars RPAREN
					{:
						
						 parser.methodCallAction(o, oleft, /* isFunctionCall = */ true);
       					 RESULT = o.getType();
       					// System.out.println("USAO U POZIV FUNKCIJE");
       					 metoda=false;
       					// argumenti=0;
					:} 
					
					|/* function_call() */
					    Designator:o LPAREN RPAREN
					    {:
					        parser.methodCallAction(o, oleft, /* isFunctionCall = */ true);
					        RESULT = o.getType();
					// System.out.println("USAO U POZIV FUNKCIJE1");
					        doneObjectAccess = false;
					    :}
						;



					
// Designator = ident { "[" Expr "]" | "." ident }.

Designator 		::= ident_expr_list:o
				    {: RESULT = o; :}
				    ;

// stuff that can sit left from assign operator
ident_expr_list ::=
				    /* array[expr] */
				    ident_expr_list:o  LSQPAREN
				    {:
				        if (o.getType().getKind() == Struct.Array ) {
				        	
				            Code.load(((Obj) o));
				            RESULT = new Obj(Obj.Elem, "", ((Obj) o).getType().getElemType());
				           }
				          
				    :}
				    Expr:t RSQPAREN
				  {:
				        if (o.getType().getKind() != Struct.Array) {
				            parser.nice_report_error(
				                "Id {0} is expected to be Array on line {1}"
				                , o.getName()
				                , oleft
				                );
				            RESULT = o;
				        }
				        if (t.getKind() != Struct.Int) {
				            parser.nice_report_error(
				              "Expression for array {0} should be int type on line {1}"
				              , o.getName()
				              , oleft
				              );
				        }
				       // System.out.println("SDASDASDASd");
				    :}
				    |
				    // error_catcher
				    ident_expr_list LSQPAREN error RSQPAREN
				    |
				    /* ident */
				    IDENT:id
				    {:
				        // Find object and print result
				        Obj ob = Tab.find(id);
				        if (ob != Tab.noObj) {
				            // We found it
				            parser.nice_print(" simbol je dohvacen iz tabele simbola ",idleft,id);
				        }
				        else if (ob == Tab.noObj) {
				            // We didn't found it
				          	  parser.nice_report_error(
						                "Pretraga na liniji {1} ({0}) nije pronadjena u tabeli simbola - nije definisana"
						                , id
						                , idleft);
				        }
				        RESULT = ob;
				    :}
				    |
				    /* obj.fld1 */
				    object_access:o
				    {: RESULT = o; :}
				    ;

object_access ::=
				    // FIXME: Wont work with multiple fields, because it is not recursive.
				    // Possible fix: use flag numOfFldAccessed if greater than 1, load prev
				    object_access:o IDENT:f_id
				    {:
				        Obj foundField;
				        
				        foundField = Tab.find(f_id);
				       
				       
				        
				        if (foundField == null)
				            parser.report_fatal_error("Greska u liniji "+f_idleft+"u tipu "+ ((Obj) o).getType() +" ne postoji field sa datim imenom "+f_id, null);
				        else {
				            RESULT = foundField; 
				            
				            currClassField = ((Obj) RESULT);
				           
				        }
				        
				    :}
				    |
				    IDENT:f_id PERIOD
				    {:
				        doneObjectAccess = true;
				
				        Obj object = Tab.find(f_id);
				        
				        
				        if (object.getType().getKind() != Struct.Class){
				            parser.report_fatal_error(
				                "Error in line "+f_idleft+
				                " it is not a class type", null);
				        } else 	instantiateOfObject++;
				        
				        RESULT = object;
				      
				    :}
				   
				    ;
					

// Relop = "==" | "!=" | ">" | ">=" | "<" | "<=".

Relop			::=   EQUEQU 	{: 	RESULT = "=="; 	:}
					| NOTEQU	{: 	RESULT = "!="; 	:}
					| GREATER	{: 	RESULT = ">"; 	:}
					| GREEQU	{: 	RESULT = ">="; 	:}
					| LESS		{: 	RESULT = "<"; 	:}
					| LESEQU	{: 	RESULT = "<="; 	:}
					;
					
// Addop = "+" | "-".

Addop			::=   PLUS
					{: RESULT = "+"; :}
					| 
					MINUS
					{: RESULT = "-"; :}
					;

// Mulop = "*" | "/" | "%".

Mulop			::=   MULT
					{: RESULT = "*"; :}
					| DEV
					{: RESULT = "/"; :}
					| PERCENT
					{: RESULT = "%"; :}
					;