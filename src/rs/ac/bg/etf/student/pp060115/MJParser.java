
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Fri Jan 17 10:35:33 CET 2014
//----------------------------------------------------

package rs.ac.bg.etf.student.pp060115;

import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.visitors.*;
import rs.etf.pp1.symboltable.factory.SymbolTableFactory;
import rs.etf.pp1.symboltable.structure.SymbolDataStructure;
import java.lang.reflect.Field;
import java_cup.parser;
import rs.etf.pp1.mj.runtime.Code;
import java_cup.runtime.*;
import java.io.*;
import java.text.MessageFormat;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Fri Jan 17 10:35:33 CET 2014
  */
public class MJParser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public MJParser() {super();}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public MJParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\223\000\002\002\010\000\002\002\004\000\002\065" +
    "\003\000\002\003\004\000\002\003\002\000\002\004\003" +
    "\000\002\072\002\000\002\004\004\000\002\004\003\000" +
    "\002\005\004\000\002\005\002\000\002\073\002\000\002" +
    "\012\011\000\002\074\002\000\002\012\011\000\002\075" +
    "\002\000\002\012\011\000\002\012\005\000\002\027\003" +
    "\000\002\027\003\000\002\070\003\000\002\071\003\000" +
    "\002\076\002\000\002\013\006\000\002\013\005\000\002" +
    "\016\005\000\002\016\003\000\002\014\003\000\002\014" +
    "\005\000\002\020\003\000\002\020\003\000\002\077\002" +
    "\000\002\100\002\000\002\101\002\000\002\022\015\000" +
    "\002\102\002\000\002\103\002\000\002\023\011\000\002" +
    "\023\006\000\002\023\006\000\002\021\004\000\002\017" +
    "\004\000\002\017\002\000\002\011\005\000\002\011\002" +
    "\000\002\007\004\000\002\007\002\000\002\104\002\000" +
    "\002\006\013\000\002\006\012\000\002\006\012\000\002" +
    "\063\004\000\002\063\004\000\002\030\003\000\002\030" +
    "\002\000\002\010\004\000\002\010\002\000\002\032\004" +
    "\000\002\032\002\000\002\024\003\000\002\031\004\000" +
    "\002\025\005\000\002\025\002\000\002\026\004\000\002" +
    "\026\006\000\002\033\003\000\002\033\003\000\002\044" +
    "\011\000\002\044\007\000\002\105\002\000\002\045\006" +
    "\000\002\045\005\000\002\045\005\000\002\045\006\000" +
    "\002\045\011\000\002\045\005\000\002\106\002\000\002" +
    "\045\010\000\002\045\007\000\002\045\007\000\002\045" +
    "\011\000\002\045\004\000\002\107\002\000\002\045\006" +
    "\000\002\045\006\000\002\045\005\000\002\045\013\000" +
    "\002\046\003\000\002\110\002\000\002\034\006\000\002" +
    "\043\003\000\002\043\002\000\002\055\004\000\002\055" +
    "\002\000\002\040\003\000\002\040\003\000\002\015\002" +
    "\000\002\042\004\000\002\041\005\000\002\041\002\000" +
    "\002\047\004\000\002\050\005\000\002\050\002\000\002" +
    "\052\004\000\002\051\005\000\002\051\002\000\002\053" +
    "\004\000\002\054\004\000\002\054\002\000\002\036\003" +
    "\000\002\037\005\000\002\037\003\000\002\057\003\000" +
    "\002\062\005\000\002\062\003\000\002\062\004\000\002" +
    "\061\003\000\002\061\003\000\002\061\005\000\002\061" +
    "\003\000\002\061\003\000\002\061\007\000\002\111\002" +
    "\000\002\061\010\000\002\061\003\000\002\112\002\000" +
    "\002\061\007\000\002\061\005\000\002\035\003\000\002" +
    "\113\002\000\002\066\007\000\002\066\006\000\002\066" +
    "\003\000\002\066\003\000\002\067\004\000\002\067\004" +
    "\000\002\056\003\000\002\056\003\000\002\056\003\000" +
    "\002\056\003\000\002\056\003\000\002\056\003\000\002" +
    "\060\003\000\002\060\003\000\002\064\003\000\002\064" +
    "\003\000\002\064\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u0102\000\004\004\005\001\002\000\004\002\u0104\001" +
    "\002\000\004\022\006\001\002\000\012\012\uffff\020\uffff" +
    "\022\uffff\054\uffff\001\002\000\012\012\ufffd\020\ufffd\022" +
    "\ufffd\054\ufffd\001\002\000\012\012\021\020\022\022\ufffb" +
    "\054\011\001\002\000\010\017\ufff7\022\ufff7\055\ufff7\001" +
    "\002\000\004\022\025\001\002\000\012\012\ufffe\020\ufffe" +
    "\022\ufffe\054\ufffe\001\002\000\012\012\uffe3\020\uffe3\022" +
    "\uffe3\054\uffe3\001\002\000\012\012\ufff9\020\ufff9\022\ufff9" +
    "\054\ufff9\001\002\000\004\054\367\001\002\000\012\012" +
    "\uffe4\020\uffe4\022\uffe4\054\uffe4\001\002\000\012\012\ufffc" +
    "\020\ufffc\022\ufffc\054\ufffc\001\002\000\004\022\046\001" +
    "\002\000\006\003\024\022\025\001\002\000\004\022\027" +
    "\001\002\000\004\047\026\001\002\000\012\003\uffc6\022" +
    "\uffc6\052\uffc6\056\uffc6\001\002\000\012\012\ufff0\020\ufff0" +
    "\022\ufff0\054\ufff0\001\002\000\004\034\030\001\002\000" +
    "\012\023\033\024\037\025\035\026\034\001\002\000\004" +
    "\047\ufff2\001\002\000\004\047\ufff4\001\002\000\004\047" +
    "\uffef\001\002\000\044\027\uffec\030\uffec\031\uffec\032\uffec" +
    "\033\uffec\035\uffec\036\uffec\037\uffec\040\uffec\041\uffec\042" +
    "\uffec\043\uffec\044\uffec\047\uffec\050\uffec\053\uffec\057\uffec" +
    "\001\002\000\044\027\uffed\030\uffed\031\uffed\032\uffed\033" +
    "\uffed\035\uffed\036\uffed\037\uffed\040\uffed\041\uffed\042\uffed" +
    "\043\uffed\044\uffed\047\uffed\050\uffed\053\uffed\057\uffed\001" +
    "\002\000\004\047\ufff6\001\002\000\004\047\uffee\001\002" +
    "\000\004\047\041\001\002\000\012\012\ufff5\020\ufff5\022" +
    "\ufff5\054\ufff5\001\002\000\004\047\043\001\002\000\012" +
    "\012\ufff3\020\ufff3\022\ufff3\054\ufff3\001\002\000\004\047" +
    "\045\001\002\000\012\012\ufff1\020\ufff1\022\ufff1\054\ufff1" +
    "\001\002\000\006\013\047\054\uffd9\001\002\000\004\022" +
    "\050\001\002\000\004\054\051\001\002\000\010\022\uffe2" +
    "\054\uffe2\055\uffe2\001\002\000\010\022\uffd7\054\uffd7\055" +
    "\uffd7\001\002\000\010\022\025\054\uffe1\055\uffe1\001\002" +
    "\000\006\003\354\022\uffeb\001\002\000\010\022\uffd8\054" +
    "\uffd8\055\uffd8\001\002\000\006\054\057\055\uffd5\001\002" +
    "\000\010\017\uffd3\022\uffd3\055\uffd3\001\002\000\004\055" +
    "\uffe0\001\002\000\004\055\062\001\002\000\012\012\uffdf" +
    "\020\uffdf\022\uffdf\054\uffdf\001\002\000\010\017\070\022" +
    "\025\055\065\001\002\000\004\022\353\001\002\000\004" +
    "\055\uffd6\001\002\000\010\017\uffd4\022\uffd4\055\uffd4\001" +
    "\002\000\004\052\072\001\002\000\004\022\071\001\002" +
    "\000\004\052\uffcd\001\002\000\010\003\074\022\025\053" +
    "\uffcb\001\002\000\004\022\350\001\002\000\004\053\343" +
    "\001\002\000\004\053\uffcc\001\002\000\004\053\103\001" +
    "\002\000\006\050\uffc3\053\uffc3\001\002\000\006\050\101" +
    "\053\uffc5\001\002\000\004\022\025\001\002\000\006\050" +
    "\uffc4\053\uffc4\001\002\000\010\003\104\022\uffc9\054\uffc9" +
    "\001\002\000\004\047\340\001\002\000\006\022\025\054" +
    "\106\001\002\000\026\005\uffd2\006\uffd2\007\uffd2\011\uffd2" +
    "\015\uffd2\016\uffd2\021\uffd2\022\uffd2\054\uffd2\055\uffd2\001" +
    "\002\000\006\022\uffca\054\uffca\001\002\000\026\005\uffc7" +
    "\006\uffc7\007\uffc7\011\uffc7\015\uffc7\016\uffc7\021\uffc7\022" +
    "\uffc7\054\uffc7\055\uffc7\001\002\000\026\005\123\006\112" +
    "\007\120\011\131\015\uffb5\016\126\021\125\022\114\054" +
    "\113\055\130\001\002\000\004\052\334\001\002\000\030" +
    "\003\327\005\uffc7\006\uffc7\007\uffc7\011\uffc7\015\uffc7\016" +
    "\uffc7\021\uffc7\022\uffc7\054\uffc7\055\uffc7\001\002\000\062" +
    "\003\uff7d\027\uff7d\030\uff7d\031\uff7d\032\uff7d\033\uff7d\034" +
    "\uff7d\035\uff7d\036\uff7d\037\uff7d\040\uff7d\041\uff7d\042\uff7d" +
    "\043\uff7d\044\uff7d\045\uff7d\046\uff7d\047\uff7d\050\uff7d\051" +
    "\326\052\uff7d\053\uff7d\056\uff7d\057\uff7d\001\002\000\026" +
    "\005\uffbf\006\uffbf\007\uffbf\011\uffbf\015\uffbf\016\uffbf\021" +
    "\uffbf\022\uffbf\054\uffbf\055\uffbf\001\002\000\014\003\305" +
    "\034\306\045\307\046\310\052\uffbc\001\002\000\062\003" +
    "\uff7c\022\304\027\uff7c\030\uff7c\031\uff7c\032\uff7c\033\uff7c" +
    "\034\uff7c\035\uff7c\036\uff7c\037\uff7c\040\uff7c\041\uff7c\042" +
    "\uff7c\043\uff7c\044\uff7c\045\uff7c\046\uff7c\047\uff7c\050\uff7c" +
    "\052\uff7c\053\uff7c\056\uff7c\057\uff7c\001\002\000\004\052" +
    "\274\001\002\000\060\003\uff81\027\uff81\030\uff81\031\uff81" +
    "\032\uff81\033\uff81\034\uff81\035\uff81\036\uff81\037\uff81\040" +
    "\uff81\041\uff81\042\uff81\043\uff81\044\uff81\045\uff81\046\uff81" +
    "\047\uff81\050\uff81\052\uff81\053\uff81\056\266\057\uff81\001" +
    "\002\000\026\005\uffc8\006\uffc8\007\uffc8\011\uffc8\015\uffc8" +
    "\016\uffc8\021\uffc8\022\uffc8\054\uffc8\055\uffc8\001\002\000" +
    "\004\052\256\001\002\000\026\005\uffc0\006\uffc0\007\uffc0" +
    "\011\uffc0\015\uffc0\016\uffc0\021\uffc0\022\uffc0\054\uffc0\055" +
    "\uffc0\001\002\000\022\014\uffaf\022\uffaf\023\uffaf\024\uffaf" +
    "\025\uffaf\026\uffaf\030\uffaf\052\uffaf\001\002\000\004\054" +
    "\243\001\002\000\004\015\133\001\002\000\010\017\uffd1" +
    "\022\uffd1\055\uffd1\001\002\000\004\047\132\001\002\000" +
    "\030\005\uffb0\006\uffb0\007\uffb0\010\uffb0\011\uffb0\015\uffb0" +
    "\016\uffb0\021\uffb0\022\uffb0\054\uffb0\055\uffb0\001\002\000" +
    "\004\052\134\001\002\000\022\014\150\022\114\023\145" +
    "\024\146\025\035\026\034\030\147\052\142\001\002\000" +
    "\046\027\uff85\030\uff85\031\uff85\032\uff85\033\uff85\035\uff85" +
    "\036\uff85\037\uff85\040\uff85\041\uff85\042\uff85\043\uff85\044" +
    "\uff85\047\uff85\050\uff85\052\236\053\uff85\057\uff85\001\002" +
    "\000\044\027\uff8f\030\uff8f\031\uff8f\032\uff8f\033\uff8f\035" +
    "\uff8f\036\uff8f\037\uff8f\040\uff8f\041\uff8f\042\uff8f\043\uff8f" +
    "\044\uff8f\047\uff8f\050\uff8f\053\uff8f\057\uff8f\001\002\000" +
    "\044\027\uff91\030\uff91\031\231\032\234\033\232\035\uff91" +
    "\036\uff91\037\uff91\040\uff91\041\uff91\042\uff91\043\uff91\044" +
    "\uff91\047\uff91\050\uff91\053\uff91\057\uff91\001\002\000\010" +
    "\043\uff98\044\uff98\053\uff98\001\002\000\024\035\222\036" +
    "\216\037\217\040\220\041\223\042\215\043\uff95\044\uff95" +
    "\053\uff95\001\002\000\022\014\150\022\114\023\145\024" +
    "\146\025\035\026\034\030\147\052\142\001\002\000\044" +
    "\027\uff8a\030\uff8a\031\uff8a\032\uff8a\033\uff8a\035\uff8a\036" +
    "\uff8a\037\uff8a\040\uff8a\041\uff8a\042\uff8a\043\uff8a\044\uff8a" +
    "\047\uff8a\050\uff8a\053\uff8a\057\uff8a\001\002\000\036\027" +
    "\207\030\210\035\uff94\036\uff94\037\uff94\040\uff94\041\uff94" +
    "\042\uff94\043\uff94\044\uff94\047\uff94\050\uff94\053\uff94\057" +
    "\uff94\001\002\000\044\027\uff8d\030\uff8d\031\uff8d\032\uff8d" +
    "\033\uff8d\035\uff8d\036\uff8d\037\uff8d\040\uff8d\041\uff8d\042" +
    "\uff8d\043\uff8d\044\uff8d\047\uff8d\050\uff8d\053\uff8d\057\uff8d" +
    "\001\002\000\044\027\uff8c\030\uff8c\031\uff8c\032\uff8c\033" +
    "\uff8c\035\uff8c\036\uff8c\037\uff8c\040\uff8c\041\uff8c\042\uff8c" +
    "\043\uff8c\044\uff8c\047\uff8c\050\uff8c\053\uff8c\057\uff8c\001" +
    "\002\000\020\014\150\022\114\023\145\024\146\025\035" +
    "\026\034\052\142\001\002\000\004\022\025\001\002\000" +
    "\036\027\uff92\030\uff92\035\uff92\036\uff92\037\uff92\040\uff92" +
    "\041\uff92\042\uff92\043\uff92\044\uff92\047\uff92\050\uff92\053" +
    "\uff92\057\uff92\001\002\000\006\044\uff9b\053\uff9b\001\002" +
    "\000\004\053\155\001\002\000\044\027\uff89\030\uff89\031" +
    "\uff89\032\uff89\033\uff89\035\uff89\036\uff89\037\uff89\040\uff89" +
    "\041\uff89\042\uff89\043\uff89\044\uff89\047\uff89\050\uff89\053" +
    "\uff89\057\uff89\001\002\000\024\005\123\006\112\007\156" +
    "\011\131\015\uffb5\016\126\021\125\022\114\054\113\001" +
    "\002\000\004\052\160\001\002\000\030\005\uffb4\006\uffb4" +
    "\007\uffb4\010\uffb4\011\uffb4\015\uffb4\016\uffb4\021\uffb4\022" +
    "\uffb4\054\uffb4\055\uffb4\001\002\000\022\014\150\022\114" +
    "\023\145\024\146\025\035\026\034\030\147\052\142\001" +
    "\002\000\004\053\162\001\002\000\024\005\123\006\112" +
    "\007\156\011\131\015\uffb5\016\126\021\125\022\114\054" +
    "\113\001\002\000\004\010\165\001\002\000\004\010\uffaa" +
    "\001\002\000\024\005\123\006\112\007\156\011\131\015" +
    "\uffb5\016\126\021\125\022\114\054\113\001\002\000\030" +
    "\005\uffb7\006\uffb7\007\uffb7\010\uffb7\011\uffb7\015\uffb7\016" +
    "\uffb7\021\uffb7\022\uffb7\054\uffb7\055\uffb7\001\002\000\006" +
    "\044\170\053\uff9d\001\002\000\022\014\150\022\114\023" +
    "\145\024\146\025\035\026\034\030\147\052\142\001\002" +
    "\000\006\044\uff9c\053\uff9c\001\002\000\006\052\uff87\056" +
    "\173\001\002\000\022\014\150\022\114\023\145\024\146" +
    "\025\035\026\034\030\147\052\142\001\002\000\004\052" +
    "\175\001\002\000\022\014\150\022\114\023\145\024\146" +
    "\025\035\026\034\030\147\052\142\001\002\000\006\050" +
    "\uff9e\053\uff9e\001\002\000\004\053\200\001\002\000\044" +
    "\027\uff86\030\uff86\031\uff86\032\uff86\033\uff86\035\uff86\036" +
    "\uff86\037\uff86\040\uff86\041\uff86\042\uff86\043\uff86\044\uff86" +
    "\047\uff86\050\uff86\053\uff86\057\uff86\001\002\000\006\050" +
    "\202\053\uffa0\001\002\000\022\014\150\022\114\023\145" +
    "\024\146\025\035\026\034\030\147\052\142\001\002\000" +
    "\006\050\uff9f\053\uff9f\001\002\000\004\057\205\001\002" +
    "\000\044\027\uff88\030\uff88\031\uff88\032\uff88\033\uff88\035" +
    "\uff88\036\uff88\037\uff88\040\uff88\041\uff88\042\uff88\043\uff88" +
    "\044\uff88\047\uff88\050\uff88\053\uff88\057\uff88\001\002\000" +
    "\044\027\uff8e\030\uff8e\031\uff8e\032\uff8e\033\uff8e\035\uff8e" +
    "\036\uff8e\037\uff8e\040\uff8e\041\uff8e\042\uff8e\043\uff8e\044" +
    "\uff8e\047\uff8e\050\uff8e\053\uff8e\057\uff8e\001\002\000\022" +
    "\014\uff73\022\uff73\023\uff73\024\uff73\025\uff73\026\uff73\030" +
    "\uff73\052\uff73\001\002\000\022\014\uff72\022\uff72\023\uff72" +
    "\024\uff72\025\uff72\026\uff72\030\uff72\052\uff72\001\002\000" +
    "\022\014\150\022\114\023\145\024\146\025\035\026\034" +
    "\030\147\052\142\001\002\000\036\027\uff93\030\uff93\035" +
    "\uff93\036\uff93\037\uff93\040\uff93\041\uff93\042\uff93\043\uff93" +
    "\044\uff93\047\uff93\050\uff93\053\uff93\057\uff93\001\002\000" +
    "\004\053\214\001\002\000\044\027\uff8b\030\uff8b\031\uff8b" +
    "\032\uff8b\033\uff8b\035\uff8b\036\uff8b\037\uff8b\040\uff8b\041" +
    "\uff8b\042\uff8b\043\uff8b\044\uff8b\047\uff8b\050\uff8b\053\uff8b" +
    "\057\uff8b\001\002\000\022\014\uff74\022\uff74\023\uff74\024" +
    "\uff74\025\uff74\026\uff74\030\uff74\052\uff74\001\002\000\022" +
    "\014\uff78\022\uff78\023\uff78\024\uff78\025\uff78\026\uff78\030" +
    "\uff78\052\uff78\001\002\000\022\014\uff77\022\uff77\023\uff77" +
    "\024\uff77\025\uff77\026\uff77\030\uff77\052\uff77\001\002\000" +
    "\022\014\uff76\022\uff76\023\uff76\024\uff76\025\uff76\026\uff76" +
    "\030\uff76\052\uff76\001\002\000\010\043\uff97\044\uff97\053" +
    "\uff97\001\002\000\022\014\uff79\022\uff79\023\uff79\024\uff79" +
    "\025\uff79\026\uff79\030\uff79\052\uff79\001\002\000\022\014" +
    "\uff75\022\uff75\023\uff75\024\uff75\025\uff75\026\uff75\030\uff75" +
    "\052\uff75\001\002\000\022\014\150\022\114\023\145\024" +
    "\146\025\035\026\034\030\147\052\142\001\002\000\010" +
    "\043\uff96\044\uff96\053\uff96\001\002\000\010\043\227\044" +
    "\uff9a\053\uff9a\001\002\000\022\014\150\022\114\023\145" +
    "\024\146\025\035\026\034\030\147\052\142\001\002\000" +
    "\010\043\uff99\044\uff99\053\uff99\001\002\000\020\014\uff71" +
    "\022\uff71\023\uff71\024\uff71\025\uff71\026\uff71\052\uff71\001" +
    "\002\000\020\014\uff6f\022\uff6f\023\uff6f\024\uff6f\025\uff6f" +
    "\026\uff6f\052\uff6f\001\002\000\020\014\150\022\114\023" +
    "\145\024\146\025\035\026\034\052\142\001\002\000\020" +
    "\014\uff70\022\uff70\023\uff70\024\uff70\025\uff70\026\uff70\052" +
    "\uff70\001\002\000\044\027\uff90\030\uff90\031\uff90\032\uff90" +
    "\033\uff90\035\uff90\036\uff90\037\uff90\040\uff90\041\uff90\042" +
    "\uff90\043\uff90\044\uff90\047\uff90\050\uff90\053\uff90\057\uff90" +
    "\001\002\000\024\014\uff84\022\uff84\023\uff84\024\uff84\025" +
    "\uff84\026\uff84\030\uff84\052\uff84\053\237\001\002\000\044" +
    "\027\uff82\030\uff82\031\uff82\032\uff82\033\uff82\035\uff82\036" +
    "\uff82\037\uff82\040\uff82\041\uff82\042\uff82\043\uff82\044\uff82" +
    "\047\uff82\050\uff82\053\uff82\057\uff82\001\002\000\022\014" +
    "\150\022\114\023\145\024\146\025\035\026\034\030\147" +
    "\052\142\001\002\000\004\053\242\001\002\000\044\027" +
    "\uff83\030\uff83\031\uff83\032\uff83\033\uff83\035\uff83\036\uff83" +
    "\037\uff83\040\uff83\041\uff83\042\uff83\043\uff83\044\uff83\047" +
    "\uff83\050\uff83\053\uff83\057\uff83\001\002\000\024\005\123" +
    "\006\112\007\156\011\131\015\uffb5\016\126\021\125\022" +
    "\114\054\113\001\002\000\004\055\245\001\002\000\004" +
    "\015\246\001\002\000\004\052\247\001\002\000\022\014" +
    "\150\022\114\023\145\024\146\025\035\026\034\030\147" +
    "\052\142\001\002\000\004\053\251\001\002\000\004\047" +
    "\252\001\002\000\030\005\uffab\006\uffab\007\uffab\010\uffab" +
    "\011\uffab\015\uffab\016\uffab\021\uffab\022\uffab\054\uffab\055" +
    "\uffab\001\002\000\022\014\150\022\114\023\145\024\146" +
    "\025\035\026\034\030\147\052\142\001\002\000\004\047" +
    "\255\001\002\000\030\005\uffae\006\uffae\007\uffae\010\uffae" +
    "\011\uffae\015\uffae\016\uffae\021\uffae\022\uffae\054\uffae\055" +
    "\uffae\001\002\000\022\014\150\022\114\023\145\024\146" +
    "\025\035\026\034\030\147\052\142\001\002\000\006\050" +
    "\260\053\261\001\002\000\004\023\263\001\002\000\004" +
    "\047\262\001\002\000\030\005\uffb2\006\uffb2\007\uffb2\010" +
    "\uffb2\011\uffb2\015\uffb2\016\uffb2\021\uffb2\022\uffb2\054\uffb2" +
    "\055\uffb2\001\002\000\004\053\264\001\002\000\004\047" +
    "\265\001\002\000\030\005\uffb1\006\uffb1\007\uffb1\010\uffb1" +
    "\011\uffb1\015\uffb1\016\uffb1\021\uffb1\022\uffb1\054\uffb1\055" +
    "\uffb1\001\002\000\024\003\267\014\uff80\022\uff80\023\uff80" +
    "\024\uff80\025\uff80\026\uff80\030\uff80\052\uff80\001\002\000" +
    "\004\057\273\001\002\000\022\014\150\022\114\023\145" +
    "\024\146\025\035\026\034\030\147\052\142\001\002\000" +
    "\004\057\272\001\002\000\060\003\uff7f\027\uff7f\030\uff7f" +
    "\031\uff7f\032\uff7f\033\uff7f\034\uff7f\035\uff7f\036\uff7f\037" +
    "\uff7f\040\uff7f\041\uff7f\042\uff7f\043\uff7f\044\uff7f\045\uff7f" +
    "\046\uff7f\047\uff7f\050\uff7f\052\uff7f\053\uff7f\056\uff7f\057" +
    "\uff7f\001\002\000\060\003\uff7e\027\uff7e\030\uff7e\031\uff7e" +
    "\032\uff7e\033\uff7e\034\uff7e\035\uff7e\036\uff7e\037\uff7e\040" +
    "\uff7e\041\uff7e\042\uff7e\043\uff7e\044\uff7e\045\uff7e\046\uff7e" +
    "\047\uff7e\050\uff7e\052\uff7e\053\uff7e\056\uff7e\057\uff7e\001" +
    "\002\000\022\014\150\022\114\023\145\024\146\025\035" +
    "\026\034\030\147\052\142\001\002\000\004\053\276\001" +
    "\002\000\024\005\123\006\112\007\120\011\131\015\uffb5" +
    "\016\126\021\125\022\114\054\113\001\002\000\026\005" +
    "\uffbd\006\uffbd\007\uffbd\011\uffbd\015\uffbd\016\uffbd\021\uffbd" +
    "\022\uffbd\054\uffbd\055\uffbd\001\002\000\004\010\302\001" +
    "\002\000\030\005\uffc0\006\uffc0\007\uffc0\010\uffaa\011\uffc0" +
    "\015\uffc0\016\uffc0\021\uffc0\022\uffc0\054\uffc0\055\uffc0\001" +
    "\002\000\024\005\123\006\112\007\120\011\131\015\uffb5" +
    "\016\126\021\125\022\114\054\113\001\002\000\026\005" +
    "\uffbe\006\uffbe\007\uffbe\011\uffbe\015\uffbe\016\uffbe\021\uffbe" +
    "\022\uffbe\054\uffbe\055\uffbe\001\002\000\062\003\uff7b\022" +
    "\uff7b\027\uff7b\030\uff7b\031\uff7b\032\uff7b\033\uff7b\034\uff7b" +
    "\035\uff7b\036\uff7b\037\uff7b\040\uff7b\041\uff7b\042\uff7b\043" +
    "\uff7b\044\uff7b\045\uff7b\046\uff7b\047\uff7b\050\uff7b\052\uff7b" +
    "\053\uff7b\056\uff7b\057\uff7b\001\002\000\004\047\325\001" +
    "\002\000\022\014\150\022\114\023\145\024\146\025\035" +
    "\026\034\030\147\052\142\001\002\000\004\047\322\001" +
    "\002\000\004\047\321\001\002\000\004\052\313\001\002" +
    "\000\004\047\320\001\002\000\024\014\uffa9\022\uffa9\023" +
    "\uffa9\024\uffa9\025\uffa9\026\uffa9\030\uffa9\052\uffa9\053\uffa9" +
    "\001\002\000\024\014\150\022\114\023\145\024\146\025" +
    "\035\026\034\030\147\052\142\053\uffa6\001\002\000\004" +
    "\053\317\001\002\000\004\053\uffa7\001\002\000\004\047" +
    "\uffa8\001\002\000\030\005\uffbb\006\uffbb\007\uffbb\010\uffbb" +
    "\011\uffbb\015\uffbb\016\uffbb\021\uffbb\022\uffbb\054\uffbb\055" +
    "\uffbb\001\002\000\030\005\uffb9\006\uffb9\007\uffb9\010\uffb9" +
    "\011\uffb9\015\uffb9\016\uffb9\021\uffb9\022\uffb9\054\uffb9\055" +
    "\uffb9\001\002\000\030\005\uffba\006\uffba\007\uffba\010\uffba" +
    "\011\uffba\015\uffba\016\uffba\021\uffba\022\uffba\054\uffba\055" +
    "\uffba\001\002\000\004\047\324\001\002\000\030\005\uffb8" +
    "\006\uffb8\007\uffb8\010\uffb8\011\uffb8\015\uffb8\016\uffb8\021" +
    "\uffb8\022\uffb8\054\uffb8\055\uffb8\001\002\000\030\005\uffb6" +
    "\006\uffb6\007\uffb6\010\uffb6\011\uffb6\015\uffb6\016\uffb6\021" +
    "\uffb6\022\uffb6\054\uffb6\055\uffb6\001\002\000\062\003\uff7a" +
    "\022\uff7a\027\uff7a\030\uff7a\031\uff7a\032\uff7a\033\uff7a\034" +
    "\uff7a\035\uff7a\036\uff7a\037\uff7a\040\uff7a\041\uff7a\042\uff7a" +
    "\043\uff7a\044\uff7a\045\uff7a\046\uff7a\047\uff7a\050\uff7a\052" +
    "\uff7a\053\uff7a\056\uff7a\057\uff7a\001\002\000\004\055\333" +
    "\001\002\000\026\005\123\006\112\007\120\011\131\015" +
    "\uffb5\016\126\021\125\022\114\054\113\055\331\001\002" +
    "\000\004\047\332\001\002\000\030\005\uffad\006\uffad\007" +
    "\uffad\010\uffad\011\uffad\015\uffad\016\uffad\021\uffad\022\uffad" +
    "\054\uffad\055\uffad\001\002\000\030\005\uffac\006\uffac\007" +
    "\uffac\010\uffac\011\uffac\015\uffac\016\uffac\021\uffac\022\uffac" +
    "\054\uffac\055\uffac\001\002\000\004\022\114\001\002\000" +
    "\004\053\336\001\002\000\004\047\337\001\002\000\030" +
    "\005\uffb3\006\uffb3\007\uffb3\010\uffb3\011\uffb3\015\uffb3\016" +
    "\uffb3\021\uffb3\022\uffb3\054\uffb3\055\uffb3\001\002\000\026" +
    "\005\uffc7\006\uffc7\007\uffc7\011\uffc7\015\uffc7\016\uffc7\021" +
    "\uffc7\022\uffc7\054\uffc7\055\uffc7\001\002\000\026\005\123" +
    "\006\112\007\120\011\131\015\uffb5\016\126\021\125\022" +
    "\114\054\113\055\342\001\002\000\010\017\uffcf\022\uffcf" +
    "\055\uffcf\001\002\000\006\022\uffc9\054\uffc9\001\002\000" +
    "\006\022\025\054\345\001\002\000\026\005\uffc7\006\uffc7" +
    "\007\uffc7\011\uffc7\015\uffc7\016\uffc7\021\uffc7\022\uffc7\054" +
    "\uffc7\055\uffc7\001\002\000\026\005\123\006\112\007\120" +
    "\011\131\015\uffb5\016\126\021\125\022\114\054\113\055" +
    "\347\001\002\000\010\017\uffd0\022\uffd0\055\uffd0\001\002" +
    "\000\010\050\uffc2\053\uffc2\056\351\001\002\000\004\057" +
    "\352\001\002\000\006\050\uffc1\053\uffc1\001\002\000\004" +
    "\052\uffce\001\002\000\004\047\366\001\002\000\004\022" +
    "\357\001\002\000\006\047\364\050\363\001\002\000\010" +
    "\047\uffe6\050\uffe6\056\361\001\002\000\006\047\uffe7\050" +
    "\uffe7\001\002\000\004\057\362\001\002\000\006\047\uffe5" +
    "\050\uffe5\001\002\000\004\022\357\001\002\000\014\012" +
    "\uffea\020\uffea\022\uffea\054\uffea\055\uffea\001\002\000\006" +
    "\047\uffe8\050\uffe8\001\002\000\014\012\uffe9\020\uffe9\022" +
    "\uffe9\054\uffe9\055\uffe9\001\002\000\012\003\370\022\uffd7" +
    "\054\uffd7\055\uffd7\001\002\000\006\047\376\055\377\001" +
    "\002\000\010\022\025\054\uffde\055\uffde\001\002\000\006" +
    "\054\057\055\uffd5\001\002\000\004\055\uffdd\001\002\000" +
    "\004\055\375\001\002\000\012\012\uffdc\020\uffdc\022\uffdc" +
    "\054\uffdc\001\002\000\012\012\uffda\020\uffda\022\uffda\054" +
    "\uffda\001\002\000\012\012\uffdb\020\uffdb\022\uffdb\054\uffdb" +
    "\001\002\000\012\012\ufffa\020\ufffa\022\ufffa\054\ufffa\001" +
    "\002\000\010\017\070\022\025\055\u0102\001\002\000\004" +
    "\002\001\001\002\000\010\017\ufff8\022\ufff8\055\ufff8\001" +
    "\002\000\004\002\000\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u0102\000\004\002\003\001\001\000\002\001\001\000" +
    "\004\065\006\001\001\000\002\001\001\000\004\003\007" +
    "\001\001\000\020\004\012\012\017\020\014\021\015\022" +
    "\016\023\013\072\011\001\001\000\004\005\u0100\001\001" +
    "\000\006\013\377\024\053\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\024" +
    "\022\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\027" +
    "\035\070\031\071\030\001\001\000\004\075\043\001\001" +
    "\000\004\074\041\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\073\037\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\077\051\001\001\000\004\017\052\001\001\000\010" +
    "\013\054\024\053\100\055\001\001\000\004\076\354\001" +
    "\001\000\002\001\001\000\004\011\057\001\001\000\004" +
    "\007\062\001\001\000\004\101\060\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\006\065\024\063\063\066" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\012\024\072\026\076\030\075\031\074\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\025\077\001\001\000\002\001\001\000" +
    "\006\024\072\026\101\001\001\000\002\001\001\000\004" +
    "\010\104\001\001\000\002\001\001\000\006\013\106\024" +
    "\053\001\001\000\004\104\107\001\001\000\002\001\001" +
    "\000\004\032\110\001\001\000\020\033\121\035\115\044" +
    "\114\045\123\066\120\067\116\106\126\001\001\000\002" +
    "\001\001\000\004\032\327\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\105\310\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\107\252\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\034" +
    "\035\134\036\140\037\143\047\152\052\151\053\137\057" +
    "\150\061\135\062\136\066\120\067\116\070\142\071\153" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\064" +
    "\232\001\001\000\004\051\225\001\001\000\006\054\220" +
    "\056\223\001\001\000\026\035\134\036\212\037\143\057" +
    "\150\061\135\062\136\066\120\067\116\070\142\071\153" +
    "\001\001\000\002\001\001\000\004\060\210\001\001\000" +
    "\002\001\001\000\002\001\001\000\016\035\134\061\205" +
    "\066\120\067\116\070\142\071\153\001\001\000\004\024" +
    "\171\001\001\000\002\001\001\000\004\050\166\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\035\115\045" +
    "\156\066\120\067\116\106\126\001\001\000\002\001\001" +
    "\000\002\001\001\000\034\035\134\036\140\037\143\047" +
    "\160\052\151\053\137\057\150\061\135\062\136\066\120" +
    "\067\116\070\142\071\153\001\001\000\002\001\001\000" +
    "\016\035\115\045\163\046\162\066\120\067\116\106\126" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\035" +
    "\115\045\165\066\120\067\116\106\126\001\001\000\002" +
    "\001\001\000\002\001\001\000\032\035\134\036\140\037" +
    "\143\052\170\053\137\057\150\061\135\062\136\066\120" +
    "\067\116\070\142\071\153\001\001\000\002\001\001\000" +
    "\004\111\173\001\001\000\026\035\134\036\203\037\143" +
    "\057\150\061\135\062\136\066\120\067\116\070\142\071" +
    "\153\001\001\000\002\001\001\000\030\035\134\036\175" +
    "\037\143\042\176\057\150\061\135\062\136\066\120\067" +
    "\116\070\142\071\153\001\001\000\004\041\200\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\026\035\134\036\202\037\143\057\150\061\135\062\136" +
    "\066\120\067\116\070\142\071\153\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\022\035\134\057" +
    "\211\061\135\062\136\066\120\067\116\070\142\071\153" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\026\035\134\036\224\037\143\057\150" +
    "\061\135\062\136\066\120\067\116\070\142\071\153\001" +
    "\001\000\002\001\001\000\002\001\001\000\030\035\134" +
    "\036\140\037\143\053\227\057\150\061\135\062\136\066" +
    "\120\067\116\070\142\071\153\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\016\035\134\061" +
    "\234\066\120\067\116\070\142\071\153\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\112\237\001\001\000" +
    "\002\001\001\000\030\035\134\036\175\037\143\042\240" +
    "\057\150\061\135\062\136\066\120\067\116\070\142\071" +
    "\153\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\035\115\045\243\066\120\067\116\106\126\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\034" +
    "\035\134\036\140\037\143\047\247\052\151\053\137\057" +
    "\150\061\135\062\136\066\120\067\116\070\142\071\153" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\026\035\134\036\253\037\143\057\150\061\135" +
    "\062\136\066\120\067\116\070\142\071\153\001\001\000" +
    "\002\001\001\000\002\001\001\000\026\035\134\036\256" +
    "\037\143\057\150\061\135\062\136\066\120\067\116\070" +
    "\142\071\153\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\113\267\001\001" +
    "\000\002\001\001\000\026\035\134\036\270\037\143\057" +
    "\150\061\135\062\136\066\120\067\116\070\142\071\153" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\034\035\134\036\140\037\143\047\274\052\151" +
    "\053\137\057\150\061\135\062\136\066\120\067\116\070" +
    "\142\071\153\001\001\000\002\001\001\000\022\033\276" +
    "\035\115\044\114\045\300\046\277\066\120\067\116\106" +
    "\126\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\016\035\115\044\302\045\165\066\120\067" +
    "\116\106\126\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\026\035\134\036\322\037\143\057" +
    "\150\061\135\062\136\066\120\067\116\070\142\071\153" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\034" +
    "\311\001\001\000\002\001\001\000\004\110\313\001\001" +
    "\000\032\035\134\036\175\037\143\042\315\043\314\057" +
    "\150\061\135\062\136\066\120\067\116\070\142\071\153" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\020\033\121\035\115" +
    "\044\114\045\123\066\120\067\116\106\126\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\035\334\066\120\067\116\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\032\340\001\001" +
    "\000\020\033\121\035\115\044\114\045\123\066\120\067" +
    "\116\106\126\001\001\000\002\001\001\000\004\010\343" +
    "\001\001\000\006\013\106\024\053\001\001\000\004\032" +
    "\345\001\001\000\020\033\121\035\115\044\114\045\123" +
    "\066\120\067\116\106\126\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\014\357\016\355\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\014\364\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\017\370\001\001\000\002\001\001\000\010\013" +
    "\054\024\053\102\371\001\001\000\004\011\372\001\001" +
    "\000\004\103\373\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\006\u0102\024\063\063\066\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$MJParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$MJParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$MJParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	
	final int boole = 5;
	final int strin = 6;
	
	final Struct bool   = new Struct(boole);
	final Struct string = new Struct(strin);
		
	//Tab.init(); // Universe scope
	
	
	Tab.currentScope().addToLocals(new Obj(Obj.Type, "bool", bool));
	Tab.currentScope().addToLocals(new Obj(Obj.Type, "string", string));
	
	

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

	Symbol s = this.getScanner().next_token();
		//if (s != null && s.value != null) 
		//nice_print("Dodajem glupost ",s.getClass());
		//System.out.println("Linija " + s.left +" pronadjen simbol   (" + s.value.toString() + ") " + s.toString());
		
	return s;

    }


int  currentLevel = 0, numFuncDecl = 0, numFuncCalls = 0,numMainStatements=0;
	
	public static void main(String args[]) throws Exception {
       
        FileReader r = null;
        
        try {
            try {
                r = new FileReader(args[0]);
            }
            catch(Exception e) {
                System.err.println("Error while opening input file: " + args[0]);
                System.exit(1);
            }

            Yylex skener = new Yylex(r);
            MJParser p     = new MJParser(skener);

            // Make universe
            Tab.init();

            // Do parsing
            System.out.println("=====================SEMANTIC ANALYSIS=========================");
            Symbol s = p.parse();

            //print counts
            System.out.println("======================SYNTAX ANALYSIS=========================");
            p.action_obj.printAllCounts();

            //my Symbol Table
            MySymbolTableVisitor stv = new MySymbolTableVisitor();
            Tab.dump(stv);

            if (p.errorDetected)
              System.out.println("Input program contains errors!");
            else
              System.out.println("Parsing successfully finished!");

            try { 
            		File objFile = new File(args[1]);
                    // System.out.println("Upisujem u " + args[1]);
                    if(objFile.exists())
                   	  objFile.delete();
                   
               if ( !p.compileError && !Code.greska )                  	                    
                    Code.write(new FileOutputStream(objFile));
                
            }
            
            catch (Exception e) {
                System.err.println("Error while writing object file: " + args[1]);
                System.exit(1);
            }



        }
        finally {
            if (r != null)
                r.close();
        }
    }
	
	private boolean errorDetected = false;
	private boolean compileError = false;
	 
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  	 
  	public void nice_print(String format, Object... arguments){
      System.out.println(MessageFormat.format("Pretraga na liniji " + (((Integer) arguments[0])<10?"0":"") + "{0} ({1}) ," + format, arguments));
    }
    
   public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska na simbolu: " + cur_token, cur_token);
   }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error(" Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

     public void report_error(String message, Object info) {
        compileError = true;
        System.err.print(message);
        System.err.flush();
        if (info instanceof Symbol)
            System.err.println(" u liniji " + ((Symbol)info).left);
        else System.err.println("");
    }
     
    	
	 public void nice_report_error(String format, Object... arguments) {
        String message = MessageFormat.format(format, arguments);
        report_error(message, null);
        System.out.println("");
    }
    
    public Obj findClassObj(String name){
      Obj resultObj = null;
      for (Scope s = Tab.currentScope(); s != null; s = s.getOuter()) {
        if (s.getLocals() != null) {
          resultObj = s.getLocals().searchKey(name);
          if (resultObj != null)
            if(resultObj.getKind() == Obj.Meth)
              continue;
            else
              break;
        }
      }
      return (resultObj != null) ? resultObj : Tab.noObj;
    }
    
     public Obj tabInsert(int kind, String id, Struct type, int line) {
        if (Tab.currentScope().findSymbol(id) != null)
            nice_report_error("Greska na liniji {1} : ({0}) je vec deklarisano. ", id, line);
        return Tab.insert(kind, id, type);
    }

    public Obj insertMethod(Struct return_type, String id, int line) {
        // MethObj -> CurrentScope
        // Open new scope
        Obj obj = tabInsert(Obj.Meth, id, return_type, line);
        Tab.openScope();

        return obj;
    }
    
     /**
     * Flag that is set when we do inner classes, so every
     * variable from Scope is set to kind of Fld.
     */
    private boolean doingInnerClass = false;

    public void setDoingInnerClass(boolean f) {
        doingInnerClass = f;
    }
    public boolean getDoingInnerClass() {
        return doingInnerClass;
    }

    /**
     * Returns Obj.Fld if we are doing innerClass or Obj.Var in other cases
     *
     * @return Obj.kind = Fld | Var
     */
    public int varOrFld() {
        if (doingInnerClass) {
            return Obj.Fld;
        }
        else {
            return Obj.Var;
        }
    }
    /**
     * Execute action for method call, so we don't have to copy/paste actions
     * for parsing methods with&without parameters
     *
     * @param o Method object
     * @param oleft Line number for error reporting
     * @param functionCall If we call it as a function(returns value)
     */
    public void methodCallAction(Obj o, int oleft, boolean functionCall) {
        // Is object of a right type
        if (o.getKind() != Obj.Meth)
            nice_report_error("Error in line {0} expected method", oleft);

        // Function call should return value
        if (functionCall && o.getType() == Tab.noType)
            nice_report_error(
                "Error in line {0} procedure called as function"
                , oleft);

        // Calc relative address
        int dest_adr = o.getAdr() - Code.pc;

        // Generate code
        Code.put(Code.call);
        Code.put2(dest_adr);
        
        if (!functionCall && o.getType() != Tab.noType){
            // Result of call won't be used
        
       
        Code.put(Code.pop);
        
        }
    }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$MJParser$actions {


	
	boolean returnFound = false;

  // Syntax Analysis counters
   private static int globalConstants = 0;
   private static int globalVars = 0;
   private static int globalArry = 0;
   private static int innerClass = 0;
   private static int innerMethod = 0;
   private static int numberOfMethodParameters = 0;
   private static int exprMain = 0;
   private static int funcInMain = 0;
   private static int defOfFunctionsInProgram = 0;
   private static int instantiateOfObject = 0;
   private static int definitionOfFields = 0;
   private static int numOfExtends = 0;
   private static short bul=0;
   private static boolean metoda = false;
   private static short argumenti = 0;
   
   public void printAllCounts() {
    System.out.println(MessageFormat.format(" {0}\tglobal constants", globalConstants));							//	R43		CONST
	System.out.println(MessageFormat.format(" {0}\tglobal vars", globalVars));										//	R43		INT , BOOL , STRING
	System.out.println(MessageFormat.format(" {0}\tglobal arrays", globalArry));									// 	R44		ARRAYS
	System.out.println(MessageFormat.format(" {0}\tdefinition of functions in program", defOfFunctionsInProgram));	// 	R45		NUMBER OF FUNCTION DEFINITIONS IN PROGRAM
	System.out.println(MessageFormat.format(" {0}\tinner class", innerClass));										//	R46
	System.out.println(MessageFormat.format(" {0}\texpression in main", exprMain));									// 	R47		STATEMENTS IN MAIN
	System.out.println(MessageFormat.format(" {0}\tfunctions in main", funcInMain));								//  R48		NUMBER OF CALL OF METHODS IN MAIN
	System.out.println(MessageFormat.format(" {0}\tinstantiate of object", instantiateOfObject));					//	R49		NUMBER OF INSTANTIATE OF OBJECTS
	System.out.println(MessageFormat.format(" {0}\tinner method", innerMethod));									//	R50		DEFINITION OF METHODS IN CLASS
	System.out.println(MessageFormat.format(" {0}\tclass fields", definitionOfFields));								//  R51		DECLARATION OF FIELDS
	//System.out.println(MessageFormat.format(" {0}\tnumberOfMethodParameters", numberOfMethodParameters));
	System.out.println(MessageFormat.format(" {0}\tnum of extends", numOfExtends));									//	R52		NUMBER OF EXTENDS
	
   }
   
   Integer boolVal = -1;
   Integer adresa = 0;
   
   Struct varType = Tab.noType;
   Struct methodType = Tab.noType;
   Struct innerClassType = null;
   
   
   String currentTypeName   = null;
   String currentTypeString = "";
   String currentString = "";
   String currentStringName = null;
   char[] str;
   Obj currentMethod=null;
   
   
   Object currVal		= null;
   Obj innerClassObj = null;
   Obj currType	= null;
   Obj currDes = null;
   Obj currClassField = null;
   Obj obj;
  
   boolean weAreInsideMain = false;
   boolean weAreInsideConstructor = false;
   boolean varDecIsGlobal = false;
   boolean returnExists = false;
   boolean doneObjectAccess = false;
   boolean instatieted = false;
   
   JumpAdrFixer jmpFixer = new JumpAdrFixer();
   LoopAdrFixer loopFixer = new LoopAdrFixer();
   Obj ca = new Obj(Obj.Con, "", Tab.intType);
   int a[] = new int[5];

  private final MJParser parser;

  /** Constructor */
  CUP$MJParser$actions(MJParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$MJParser$do_action(
    int                        CUP$MJParser$act_num,
    java_cup.runtime.lr_parser CUP$MJParser$parser,
    java.util.Stack            CUP$MJParser$stack,
    int                        CUP$MJParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$MJParser$result;

      /* select the action based on the action number */
      switch (CUP$MJParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // Mulop ::= PERCENT 
            {
              String RESULT =null;
		 RESULT = "%"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // Mulop ::= DEV 
            {
              String RESULT =null;
		 RESULT = "/"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // Mulop ::= MULT 
            {
              String RESULT =null;
		 RESULT = "*"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Mulop",50, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // Addop ::= MINUS 
            {
              String RESULT =null;
		 RESULT = "-"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // Addop ::= PLUS 
            {
              String RESULT =null;
		 RESULT = "+"; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Addop",46, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // Relop ::= LESEQU 
            {
              Object RESULT =null;
		 	RESULT = "<="; 	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // Relop ::= LESS 
            {
              Object RESULT =null;
		 	RESULT = "<"; 	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // Relop ::= GREEQU 
            {
              Object RESULT =null;
		 	RESULT = ">="; 	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // Relop ::= GREATER 
            {
              Object RESULT =null;
		 	RESULT = ">"; 	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // Relop ::= NOTEQU 
            {
              Object RESULT =null;
		 	RESULT = "!="; 	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // Relop ::= EQUEQU 
            {
              Object RESULT =null;
		 	RESULT = "=="; 	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Relop",44, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // object_access ::= IDENT PERIOD 
            {
              Obj RESULT =null;
		int f_idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int f_idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String f_id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				        doneObjectAccess = true;
				
				        Obj object = Tab.find(f_id);
				        
				        
				        if (object.getType().getKind() != Struct.Class){
				            parser.report_fatal_error(
				                "Error in line "+f_idleft+
				                " it is not a class type", null);
				        } else 	instantiateOfObject++;
				        
				        RESULT = object;
				      
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("object_access",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // object_access ::= object_access IDENT 
            {
              Obj RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int f_idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int f_idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String f_id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				        Obj foundField;
				        
				        foundField = Tab.find(f_id);
				       
				       
				        
				        if (foundField == null)
				            parser.report_fatal_error("Greska u liniji "+f_idleft+"u tipu "+ ((Obj) o).getType() +" ne postoji field sa datim imenom "+f_id, null);
				        else {
				            RESULT = foundField; 
				            
				            currClassField = ((Obj) RESULT);
				           
				        }
				        
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("object_access",53, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // ident_expr_list ::= object_access 
            {
              Obj RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = o; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ident_expr_list",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // ident_expr_list ::= IDENT 
            {
              Obj RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				        // Find object and print result
				        Obj ob = Tab.find(id);
				        if (ob != Tab.noObj) {
				            // We found it
				            parser.nice_print(" simbol je dohvacen iz tabele simbola ",idleft,id);
				        }
				        else if (ob == Tab.noObj) {
				            // We didn't found it
				          	  parser.nice_report_error(
						                "Pretraga na liniji {1} ({0}) nije pronadjena u tabeli simbola - nije definisana"
						                , id
						                , idleft);
				        }
				        RESULT = ob;
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ident_expr_list",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // ident_expr_list ::= ident_expr_list LSQPAREN error RSQPAREN 
            {
              Obj RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ident_expr_list",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // ident_expr_list ::= ident_expr_list LSQPAREN NT$17 Expr RSQPAREN 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$17
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				        if (o.getType().getKind() != Struct.Array) {
				            parser.nice_report_error(
				                "Id {0} is expected to be Array on line {1}"
				                , o.getName()
				                , oleft
				                );
				            RESULT = o;
				        }
				        if (t.getKind() != Struct.Int) {
				            parser.nice_report_error(
				              "Expression for array {0} should be int type on line {1}"
				              , o.getName()
				              , oleft
				              );
				        }
				       // System.out.println("SDASDASDASd");
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ident_expr_list",52, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // NT$17 ::= 
            {
              Obj RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

				        if (o.getType().getKind() == Struct.Array ) {
				        	
				            Code.load(((Obj) o));
				            RESULT = new Obj(Obj.Elem, "", ((Obj) o).getType().getElemType());
				           }
				          
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$17",73, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // Designator ::= ident_expr_list 
            {
              Obj RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = o; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Designator",27, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // Factor ::= Designator LPAREN RPAREN 
            {
              Struct RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
					        parser.methodCallAction(o, oleft, /* isFunctionCall = */ true);
					        RESULT = o.getType();
					// System.out.println("USAO U POZIV FUNKCIJE1");
					        doneObjectAccess = false;
					    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // Factor ::= Designator LPAREN NT$16 ActPars RPAREN 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$16
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
						
						 parser.methodCallAction(o, oleft, /* isFunctionCall = */ true);
       					 RESULT = o.getType();
       					// System.out.println("USAO U POZIV FUNKCIJE");
       					 metoda=false;
       					// argumenti=0;
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // NT$16 ::= 
            {
              Struct RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
metoda=true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$16",72, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // Factor ::= Designator 
            {
              Struct RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					   	
					   		if ( o.equals(Obj.Var)  
					            && o.equals(Obj.Elem)
					            && o.equals(Obj.Fld)
					            && o.equals(Obj.Con)) {
					
					            parser.nice_report_error(
					                "Error in line {0} expected type with value" , ((Obj) o)
					                );
					
					        }
						
					        // load first "this" param implicitly for all fields
					        // that have no loaded object
					        if (parser.getDoingInnerClass()
					                && o.equals(Obj.Fld)
					                && !doneObjectAccess) {
					            Obj _this_ = Tab.find("this");
					            Code.load(_this_);
					        }
					       
					       if(!o.getName().equalsIgnoreCase("funkcija")){ Code.load(o); }
					       else{ 
					       parser.methodCallAction(o, oleft, /* isFunctionCall = */ true);
					       System.out.println("ASDASDASD");
					       }
					        
					       	RESULT = o.getType();
					       	 definitionOfFields++;
					
					        doneObjectAccess = false;
					    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // Factor ::= NEW Type NT$15 LPAREN ActPars RPAREN 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$15
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
					        // First: find class belonging to type
					        Obj klass = Tab.find(currentTypeString);
					
					        // Second: Find constructor
					        Obj constructor = klass.getType() /* Struct */
					 /* SymbolDataStructure */  .getMembers()
					 /* Obj                 */  .searchKey(currentTypeString);
					
					        // Third: If it exists, call it
					        if (constructor != null) {
					            parser.methodCallAction(constructor, tleft, /* functionCall = */ true);
					        }
					
					        RESULT = t;
					    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // NT$15 ::= 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

				            // Use this as "this" if we call constructor
				            Code.put(Code.new_);
				            Code.put2(t.getNumberOfFields());
				        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$15",71, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // Factor ::= NEW Type LSQPAREN Expr RSQPAREN 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int t1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t1 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
				    	//System.out.println("AAAAAA");
				        if (t1 != Tab.intType)
				            parser.nice_report_error("Error in line {0} length of array must be int", tleft);
				        Code.put(Code.newarray);
				        if (t == Tab.charType)
				            Code.put(0);
				          else
				            Code.put(1);
				           
				        RESULT = new Struct(Struct.Array, t);
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // Factor ::= string_expr 
            {
              Struct RESULT =null;
		int stleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int stright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String st = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
			
					
					System.out.println("SSTTRRIINNGG"+currentTypeName);
					
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // Factor ::= bool_expr 
            {
              Struct RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 	
						bul=1; 
						Obj o = new Obj(Obj.Con, "", Tab.intType);
					   	if(b.booleanValue()==false){
					     	//
					     	o.setAdr(48);
					     	Code.load(o);
					     }
						else{  
							//
							o.setAdr(49);
							Code.load(o);
					   }
						RESULT = Tab.find(currentTypeName).getType();
						//System.out.println("|AS"+currentTypeName);
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // Factor ::= LPAREN Expr RPAREN 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					
					//System.out.println("USAO u"+t);
					Obj klass = Tab.find(currentTypeString);
					
					Obj constructor = klass.getType().getMembers().searchKey(currentTypeString);
					
				    if (constructor != null) {
					   parser.methodCallAction(constructor, tleft, true);
					}
									
					 RESULT=t; 
					 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // Factor ::= CHARCONST 
            {
              Struct RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Character c = (Character)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				        Obj o = new Obj(Obj.Con, "", Tab.charType);
				        o.setAdr(c.charValue());
				        Code.load(o);
				        RESULT = Tab.charType;
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // Factor ::= NUMBER 
            {
              Struct RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					 	if(!metoda){
					        Obj c = new Obj(Obj.Con, "", Tab.intType);
					        c.setAdr(i.intValue());
					        Code.load(c);
					        RESULT = Tab.intType;
					       // System.out.println("nije metoda poziv parametara"+i.intValue());
					     }else{

					    	
						        ca.setAdr(i.intValue());
						        Code.load(ca);
						        RESULT = Tab.intType;
					     	//System.out.println("metoda poziv parametara"+i.intValue());   
					     	a[argumenti]=i;
					     	argumenti++;
					        }
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Factor",47, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // FactorList ::= MINUS Factor 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			        Code.put(Code.neg);
			        RESULT = t;
			    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FactorList",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // FactorList ::= Factor 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 RESULT = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FactorList",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // FactorList ::= FactorList Mulop Factor 
            {
              Struct RESULT =null;
		int t1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct t1 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int t2left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int t2right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t2 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				        if (s.equals("*"))
				            Code.put(Code.mul);
				        else if (s.equals("/"))
				            Code.put(Code.div);
				        else if(s.equals("%"))
				        	Code.put(Code.rem);
				        RESULT = t2;
				 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FactorList",48, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // Term ::= FactorList 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					RESULT=t; 
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Term",45, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // ExprListDef ::= Term 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		 
    				   				
    				RESULT = t; 
    				
    				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprListDef",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // ExprListDef ::= ExprListDef Addop Term 
            {
              Struct RESULT =null;
		int t1left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct t1 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int t2left = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int t2right = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t2 = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					        if (s.equals("+"))
					            Code.put(Code.add);
					        else if (s.equals("-"))
					            Code.put(Code.sub);
					        RESULT = t1;
					   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprListDef",29, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // Expr ::= ExprListDef 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		RESULT = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Expr",28, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // CondFactExp ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFactExp",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // CondFactExp ::= Relop Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFactExp",42, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // CondFact ::= Expr CondFactExp 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFact",41, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // CondFactAND ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFactAND",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // CondFactAND ::= CondFactAND AND CondFact 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondFactAND",39, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // CondTerm ::= CondFact CondFactAND 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTerm",40, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // CondTermOR ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTermOR",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // CondTermOR ::= CondTermOR OR CondTerm 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CondTermOR",38, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // Condition ::= CondTerm CondTermOR 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Condition",37, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // ExprListAP ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprListAP",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // ExprListAP ::= ExprListAP COMMA Expr 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprListAP",31, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // ActPars ::= Expr ExprListAP 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActPars",32, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // dummy_terminal ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("dummy_terminal",11, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // ExprRet ::= dummy_terminal 
            {
              Object RESULT =null;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object dummy = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					        if (methodType != Tab.noType)
					            parser.nice_report_error(
					                "Error in line {0} method must have return statement"
					                , dummyleft);
					    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprRet",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // ExprRet ::= Expr 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				    	System.out.println("T = "+t);
				    	System.out.println("Metoda = "+methodType);
				        if (!t.assignableTo(methodType)){
				            parser.nice_report_error(
				                "Error in line {0} type not compatible with method declaration"
				                , tleft);
				                }
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ExprRet",30, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // ReadExprList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReadExprList",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // ReadExprList ::= COMMA NUMBER 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ReadExprList",43, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // ActParsSt ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActParsSt",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // ActParsSt ::= ActPars 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ActParsSt",33, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // DesignatorList ::= LPAREN NT$14 ActParsSt RPAREN 
            {
              Object RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
						metoda=false;
				        if (weAreInsideMain) funcInMain++;
				        parser.methodCallAction(currDes, currDes.getAdr(), false);
				        // System.out.println("USAO U POZIV FUNKCIJE");
						//argumenti=0;
				        doneObjectAccess = false;
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DesignatorList",26, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // NT$14 ::= 
            {
              Object RESULT =null;
metoda=true;argumenti=0;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$14",70, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // machedInAction ::= Matched 
            {
              Object RESULT =null;
		
				        /* 3 = jmp.length + address_length */
				        jmpFixer.fixCurAdrLevel(Code.pc + 3);
				        Code.put(Code.jmp);
				
				        jmpFixer.newAdrLevel(Code.pc);
				        Code.put2(0);
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("machedInAction",36, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // Matched ::= DO LBRACE Matched RBRACE WHILE LPAREN Condition RPAREN SEMICOL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // Matched ::= LBRACE error RBRACE 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                  		parser.nice_report_error("Greska unutar definisanja izraza. Oporavak do }.",lleft);
                	  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // Matched ::= LBRACE StatementList RBRACE SEMICOL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // Matched ::= RETURN NT$13 Expr SEMICOL 
            {
              Object RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object dummy = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					if(currentMethod.getName().equals("main")) parser.numMainStatements++;
					
					returnFound = true;
					Struct currMethType = currentMethod.getType();
					
					if ( !currMethType.compatibleWith(t) ) {
						parser.report_error(" Greska na liniji: " + tleft + " tip izraza u return naredbi ne slaze se s tipom povratne vrednosti funkcije: " + currentMethod.getName(), null);
					}
					else {
						Code.put(Code.exit);
						Code.put(Code.return_);
					}
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // NT$13 ::= 
            {
              Object RESULT =null;
		int dummyleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dummyright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object dummy = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

					   returnExists = true;
					 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$13",69, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // Matched ::= BREAK SEMICOL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // Matched ::= PRINT LPAREN Expr COMMA NUMBER RPAREN SEMICOL 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int numleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int numright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer num = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
							int i = num.intValue();
							
							if (weAreInsideMain) funcInMain++; 
							
							if (t != Tab.intType && t != Tab.charType  && t != Tab.find("bool").getType() && t != Tab.find("string").getType())
					           parser.nice_report_error("Error in line {0} expr type must be int or char", tleft);
					       
					        if (t == Tab.intType) {
					            // width of printout
					            
					            Code.loadConst(i);
					            Code.put(Code.print);
					            
					        } else if( t == Tab.charType ) {
					            // width of printout
					            
					            Code.loadConst(i);					            
					            Code.put(Code.bprint);
					            
					        } else if(t == Tab.find("bool").getType()){
					        	//System.out.println("USAO U BOOL");
					        	Code.loadConst(i);	
					        	Code.put(Code.bprint);
					        }
					            else if(t == Tab.find("string").getType()){
					        	//System.out.println("USAO U STRING "+ currentString  +" DUZINA = "+currentString.length());
					        	
	                 				Code.loadConst(i);
	                 				Code.put(Code.bprint);
	                 				
						    
					        	
					        }
					 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // Matched ::= PRINT LPAREN Expr RPAREN SEMICOL 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
							
							
							if (weAreInsideMain) funcInMain++; 
							
							if (t != Tab.intType && t != Tab.charType  && t != Tab.find("bool").getType() && t != Tab.find("string").getType())
					           parser.nice_report_error("Error in line {0} expr type must be int or char", tleft);
					       
					        if (t == Tab.intType) {
					            // width of printout
					            
					            Code.loadConst(5);
					            Code.put(Code.print);
					            
					        } else if( t == Tab.charType ) {
					            // width of printout
					            
					            Code.loadConst(1);					            
					            Code.put(Code.bprint);
					            
					        } else if(t == Tab.find("bool").getType()){
					        	//System.out.println("USAO U BOOL");
					        	Code.loadConst(1);
					        	Code.put(Code.bprint);
					        }
					            else if(t == Tab.find("string").getType()){
					        	//System.out.println("USAO U STRING "+ currentString  +" DUZINA = "+currentString.length());
					        	
	                 				Code.loadConst(1);
	                 				Code.put(Code.bprint);
	                 				
						    
					        	
					        }
					 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // Matched ::= READ LPAREN Designator RPAREN SEMICOL 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		 
					
							if (weAreInsideMain) funcInMain++;  
					
						if (d.getType() != Tab.intType && d.getType() != Tab.charType  && d.getType() != Tab.find("bool").getType() && d.getType() != Tab.find("string").getType())
					           parser.nice_report_error("Error in line {0} expr type must be int or char", dleft);
					    
					    
						    if(d.getType() == Tab.intType) {
		                    Code.put(Code.read);
		                } 
						else if(d.getType() == Tab.charType){
		                    Code.put(Code.bread);
		                }
						else if(d.getType() == Tab.find("bool").getType()){
		                    Code.put(Code.read);
		                }
						else if(d.getType() == Tab.find("string").getType()){
		                   for(int i=0;i<currentString.length();i++)
		                   	Code.put(Code.bread);
		                }
		            
		               currType = Tab.find(d.getName());
		               
		               if(currType!=null){
		            	
		            	
		            	            	  
					   	Code.store(d);
					  // System.out.println("USAO");
					   }
					 
				   
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // Matched ::= NT$12 WHILE LPAREN Condition RPAREN Matched 
            {
              Object RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		
				        Code.put(Code.jmp);
				        Code.put2(loopFixer.popCurrentLoopTop() - (Code.pc - 1));// 1 = jmp op
				        //System.out.println("Relative address " + (whileTop - Code.pc));
				        jmpFixer.fixCurAdrLevel(Code.pc);
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // NT$12 ::= 
            {
              Object RESULT =null;
loopFixer.saveLoopTop(Code.pc);
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$12",68, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // Matched ::= Designator error SEMICOL 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // Matched ::= IF LPAREN Condition RPAREN machedInAction ELSE Matched 
            {
              Object RESULT =null;
		
				        jmpFixer.fixCurAdrLevel(Code.pc);
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // Matched ::= Designator EQUALS Expr SEMICOL 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj o = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		
					 if (weAreInsideMain) exprMain++; 
					 if (t == null)
			            System.out.println("t is null");
			         else if (o == null)
			            System.out.println("o is null");
			         else if (((Obj)o).getType() == null)
			            System.out.println("o.type is null");
			
			         // Check if assignable
			       	 if(bul==1){
			         	Code.store(o);
			         	bul=0;
			         	//System.out.println("Dodao bul");			         	
			         }
			         else{
			       		if (t.assignableTo(o.getType()) )
            				Code.store(o);
			        	 else{
			           	 parser.nice_report_error(
			            	  "Error in line {0} incompatibile types used in assignment"
			              	, oleft);
			         	}
					 }
			        // Check for constants on left side
			        if (((Obj)o).getKind() == Obj.Con) {
			            parser.nice_report_error(
			              "Id {0} is constant on left side of assignment, at line {1}"
			              , ((Obj)o).getName()
			              , oleft);
			        }
			
			        doneObjectAccess = false;
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // Matched ::= Designator DECREM SEMICOL 
            {
              Object RESULT =null;
		int destleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int destright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj dest = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
					if(currentMethod.getName().equals("main")) parser.numMainStatements++;
					
					if ( (dest.getKind() != Obj.Var) && (dest.getKind() != Obj.Elem) )	//dest.getType() != Tab.intType || 
						parser.report_error( "Greska na liniji: " + destleft + ": " + dest.getName() + " nije promenljiva." , null);
					else{
						Code.load(dest);
						Obj c = Tab.insert(Obj.Con, "", Tab.intType);
						c.setAdr(1);
						Code.load(c);
						Code.put(Code.sub);
						Code.store(dest);
					}
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // Matched ::= Designator INCREM SEMICOL 
            {
              Object RESULT =null;
		int destleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int destright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Obj dest = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
					if(currentMethod.getName().equals("main")) parser.numMainStatements++;
					
					if ( (dest.getKind() != Obj.Var) && (dest.getKind() != Obj.Elem) )	//dest.getType() != Tab.intType ||
						parser.report_error( "Greska na liniji: " + destleft + ": " + dest.getName() + " nije promenljiva." , null);
					else{
					
						Code.load(dest);
						Obj c = Tab.insert(Obj.Con, "", Tab.intType);
						c.setAdr(1);
						Code.load(c);
						Code.put(Code.add);
						Code.store(dest);
						
					}
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // Matched ::= Designator NT$11 DesignatorList SEMICOL 
            {
              Object RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Matched",35, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // NT$11 ::= 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 if (weAreInsideMain) exprMain++; currDes=d; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$11",67, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // Unmatched ::= IF LPAREN Condition RPAREN Statement 
            {
              Object RESULT =null;
		
				        jmpFixer.fixCurAdrLevel(Code.pc);
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // Unmatched ::= IF LPAREN Condition RPAREN machedInAction ELSE Unmatched 
            {
              Object RESULT =null;
		
				        jmpFixer.fixCurAdrLevel(Code.pc);
				    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Unmatched",34, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // Statement ::= Unmatched 
            {
              Object RESULT =null;
		
						if (weAreInsideMain)
           					exprMain++;
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // Statement ::= Matched 
            {
              Object RESULT =null;
		
						if (weAreInsideMain)
           					exprMain++;
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Statement",25, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // TypeDef ::= Type IDENT LSQPAREN RSQPAREN 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
						numberOfMethodParameters ++; 
					    Tab.insert(Obj.Var, id, new Struct(Struct.Array, t));
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("TypeDef",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // TypeDef ::= Type IDENT 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				   		argumenti++;
				   		numberOfMethodParameters ++; 
				        Tab.insert(Obj.Var, id, t);
				   
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("TypeDef",20, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // TypeDefList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("TypeDefList",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // TypeDefList ::= TypeDefList COMMA TypeDef 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("TypeDefList",19, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // FormPars ::= TypeDef TypeDefList 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormPars",23, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					    
						currentTypeString = id;
						
					    Obj newObj = Tab.find(id);
					    if(newObj!=null) currentTypeName = id;
					
					    if(newObj.getKind() == Obj.Meth){
					      newObj = parser.findClassObj(currentTypeName);
					      System.out.println("METODAAAA");
					    }
					
					    if(newObj.getKind() != Obj.Type){
					      parser.nice_report_error("{1} nije tip podatka!", idleft, id);
					      newObj = Tab.noObj;
					    }
					    RESULT = newObj.getType();
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Type",18, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // StatementList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // StatementList ::= StatementList Statement 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("StatementList",24, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // MDVar ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MDVar",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // MDVar ::= MDVar VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MDVar",6, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // FormParsList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParsList",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // FormParsList ::= FormPars 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("FormParsList",22, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // MethodTypeName ::= VOID IDENT 
            {
              Integer RESULT =null;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				Obj resultObj = null;
				Scope s = Tab.currentScope();
				
				if (s.getLocals() != null) resultObj = s.getLocals().searchKey(methName);
			
				Obj temp = (resultObj != null) ? resultObj : Tab.noObj;
				
				if ( temp!=Tab.noObj ) { 
					parser.report_error("Greska na liniji: "+ methNameleft + ", metoda: " + methName + " je vec deklarisana.",null);
					RESULT=0;
				}
				else {
					parser.numFuncDecl++;	//if( !methName.equals("main") ) 
					currentMethod = Tab.insert(Obj.Meth, methName, Tab.noType);
					parser.currentLevel++;
					Tab.openScope();
					RESULT=1;
				}			
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodTypeName",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // MethodTypeName ::= Type IDENT 
            {
              Integer RESULT =null;
		int retTypeleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int retTyperight = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Struct retType = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
				Obj resultObj = null;
				Scope s = Tab.currentScope();
				
				if (s.getLocals() != null) resultObj = s.getLocals().searchKey(methName);	// provera da li postoji metoda s tim imenom
			
				Obj temp = (resultObj != null) ? resultObj : Tab.noObj;
				
				if ( temp!=Tab.noObj ) { 
					parser.report_error("Greska na liniji: "+ methNameleft + ", metoda: " + methName + " je vec deklarisana.",null);
					RESULT=0;
				}
				else {
					parser.numFuncDecl++;	//if( !methName.equals("main") ) 
					currentMethod = Tab.insert(Obj.Meth, methName, retType);
					parser.currentLevel++;
					Tab.openScope();
					RESULT=1;
				}
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodTypeName",49, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // MethodDecl ::= MethodTypeName LPAREN FormParsList RPAREN error SEMICOL StatementList RBRACE 
            {
              Object RESULT =null;
		int methodleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int methodright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		Integer method = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int errleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		
					parser.report_error("Greska pri definiciji lokalnih promenljiva kod metode do ;. Na liniji: " + errleft, null);
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // MethodDecl ::= MethodTypeName LPAREN error RPAREN MDVar LBRACE StatementList RBRACE 
            {
              Object RESULT =null;
		int errleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int errright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Object err = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		
					parser.report_error("Greska na liniji: " + errleft + " deklaracija formalnih parametara u funkciji nekorektna.", null);
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // MethodDecl ::= MethodTypeName LPAREN FormParsList RPAREN MDVar LBRACE NT$10 StatementList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int existsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).left;
		int existsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).right;
		Integer exists = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)).value;
		
				if (exists==1){
					if ( !returnFound && currentMethod.getType() != Tab.noType )
						parser.report_error(" Semanticka greska: u metodi " + currentMethod.getName() + " nedostaje return iskaz!", null);
				
					Code.put(Code.exit);//zavrsne instrukcije unutar metode
					Code.put(Code.return_);
					
					Tab.chainLocalSymbols(currentMethod);
					Tab.closeScope();
					
					returnFound = false;
					currentMethod = null;
					parser.currentLevel--;
				}
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDecl",4, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-8)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // NT$10 ::= 
            {
              Object RESULT =null;
		int existsleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int existsright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Integer exists = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;

				if (exists==1){
					currentMethod.setAdr(Code.pc);
					if ("main".equals(currentMethod.getName())){
						Code.mainPc = currentMethod.getAdr();
					}
					Code.put(Code.enter);//enter instrukcija
					if(("main".equals(currentMethod.getName())))
					Code.put(currentMethod.getLevel());//u level polju cuvamo broj argumenata metode
					else{ Code.put(argumenti);// System.out.println("Stavio argumente "+argumenti);
					}
					Code.put(Tab.currentScope().getnVars());
				}
				
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$10",66, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // MDLista ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MDLista",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // MDLista ::= MDLista MethodDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MDLista",5, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // MethodDeclUCL ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclUCL",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // MethodDeclUCL ::= LBRACE MDLista RBRACE 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclUCL",7, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // VarDeclCL ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclCL",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // VarDeclCL ::= VarDeclCL VarDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDeclCL",13, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // ClassIdent ::= CLASS IDENT 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					        
					        innerClassType = new Struct(Struct.Class);
					
					        RESULT        = parser.tabInsert(Obj.Type, id, innerClassType, idleft);
					        innerClassObj = (Obj) RESULT;
					        Tab.openScope();
					
					        parser.setDoingInnerClass(true);
					    
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassIdent",15, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // ClassDeclU ::= ClassIdent LBRACE error SEMICOL 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		 parser.debug_message("Uspesan oporavak od greske pri dodeli vrednosti."); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDeclU",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // ClassDeclU ::= ClassIdent LBRACE error RBRACE 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		 parser.debug_message("Uspesan oporavak od greske pri dodeli vrednosti."); 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDeclU",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // ClassDeclU ::= ClassIdent LBRACE VarDeclCL NT$8 MethodDeclUCL NT$9 RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDeclU",17, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // NT$9 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;

						     // Insert methods&fields inside obj
						        
						     ((Obj) o).getType().setMembers(Tab.currentScope().getLocals());
						
						     innerClass++;
						
						     // Clean up
						     Tab.closeScope();
						     parser.setDoingInnerClass(false);
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$9",65, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // NT$8 ::= 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;

				      		// Set field members of a inner class
				       		((Obj) o).getType().setMembers(Tab.currentScope().getLocals());
				      
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$8",64, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // ClassDeclM ::= CLASS IDENT EXTENDS IDENT LBRACE NT$5 VarDeclCL NT$6 MethodDeclUCL NT$7 RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-9)).value;
		int nasledjenaleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int nasledjenaright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		String nasledjena = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDeclM",16, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-10)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // NT$7 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-7)).value;
		int nasledjenaleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int nasledjenaright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		String nasledjena = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;

						     // Insert methods&fields inside obj
						     if(RESULT != Tab.noObj){ 
						     ((Obj) RESULT).getType().setMembers(Tab.currentScope().getLocals());
						
						     innerClass++;
							 }
						     // Clean up
						     Tab.closeScope();
						     parser.setDoingInnerClass(false);
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$7",63, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // NT$6 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int nasledjenaleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int nasledjenaright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		String nasledjena = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;

					  		if(RESULT != Tab.noObj){
				      		((Obj) RESULT).getType().setMembers(Tab.currentScope().getLocals());
				       		System.out.println("Klasa "+ ((Obj) RESULT).getName() +" nasledjuje klasu " + nasledjena.toString()  );
				       		}
				      
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$6",62, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // NT$5 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int nasledjenaleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int nasledjenaright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		String nasledjena = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;

					  	if(Tab.find(nasledjena.toString())==Tab.noObj ){
				       		
				       			System.out.println("Klasa " + nasledjena.toString() + " nije definisana - te je nemoguce naslediti je." );
				       			RESULT = Tab.noObj;		
				       			Tab.openScope();		       			
				       		}else{
				       		
					    
					        
					        innerClassType = new Struct(Struct.Class);
					
					        RESULT        = parser.tabInsert(Obj.Type, id, innerClassType, idleft);
					        innerClassObj = (Obj) RESULT;
					        Tab.openScope();
							numOfExtends++;
					        parser.setDoingInnerClass(true);
					    }
				       		
					  
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$5",61, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // ClassDecl ::= ClassDeclU 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // ClassDecl ::= ClassDeclM 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ClassDecl",14, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // VDD ::= IDENT LSQPAREN RSQPAREN 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		
							//Obj o = parser.tabInsert(parser.varOrFld(), id, new Struct(Struct.Array, varType), idleft);
							//parser.nice_print(" nadjeno Var {1} Array of : " + currentTypeName.toString() +", " + o.getAdr() + ", " + o.getLevel() , idleft, id);
							
							parser.tabInsert(parser.varOrFld(), id, new Struct(Struct.Array, varType), idleft);
							if (varDecIsGlobal) {
								globalArry++;
							}
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VDD",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // VDD ::= IDENT 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
							//Obj o = parser.tabInsert(parser.varOrFld(), id, new Struct(varType.getKind(), varType), idleft);
							//parser.nice_print(" nadjeno Var {1} : " + currentTypeName.toString() +", " + o.getAdr() + ", " + o.getLevel() , idleft, id);
							parser.tabInsert(parser.varOrFld(), id, varType, idleft);
							if (varDecIsGlobal) {
								globalVars++;
							}
						
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VDD",10, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // VDDList ::= VDD 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VDDList",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // VDDList ::= VDDList COMMA VDD 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VDDList",12, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // VarDecl ::= Type error SEMICOL 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
               			 parser.nice_report_error("Deklaracija promenljivih GRESKA. Oporavak do ;.",lleft);
              		
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // VarDecl ::= Type NT$4 VDDList SEMICOL 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("VarDecl",9, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // NT$4 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
 varType = t; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$4",60, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // string_expr ::= STRCONST 
            {
              String RESULT =null;
		int scleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int scright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String sc = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					  RESULT = (String)sc.toString();
					  currentString = (String)sc.toString();
					  currentTypeName = "string";
					 
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("string_expr",55, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // bool_expr ::= BOOLCONST 
            {
              Boolean RESULT =null;
		int bcleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int bcright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean bc = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
					  RESULT = bc.booleanValue();
					  if(bc.booleanValue() == true) boolVal = 1;
					  else boolVal = 0;
					  currentTypeName = "bool";
					
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("bool_expr",54, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // CDD ::= CHARCONST 
            {
              Integer RESULT =null;
		int ccleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int ccright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Character cc = (Character)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			          RESULT = (int)cc.charValue();
					  currVal = (int)cc.charValue();
					  currentTypeName = "char";
			        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CDD",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // CDD ::= NUMBER 
            {
              Integer RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
			          RESULT = i;
					  currVal = i;
					  currentTypeName = "int";
			        
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("CDD",21, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // ConstDecl ::= CONST error SEMICOL 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		
                  		parser.nice_report_error("Deklaracija konstante GRESKA. Oporavak do ;.",lleft);
                	
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // ConstDecl ::= CONST Type IDENT EQUALS string_expr NT$3 SEMICOL 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int vright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String v = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // NT$3 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String v = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                 		Obj o = parser.tabInsert(Obj.Con, id, t, tleft);
                 		//parser.tabInsert(parser.varOrFld(), id, varType, idleft);
                 		
                 		//for(int i=0; i <v.length();i++){
                 		Code.put(Code.newarray);
                		Code.store(Tab.find(v));
                 		//}
                  		
               		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$3",59, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // ConstDecl ::= CONST Type IDENT EQUALS bool_expr NT$2 SEMICOL 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int vright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Boolean v = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // NT$2 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Boolean v = (Boolean)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                 		Obj o = parser.tabInsert(Obj.Con, id, t, tleft);
                 		o.setAdr( boolVal );
                  		parser.nice_print(" nadjeno Con BOOL {1} : " + currentTypeName.toString() +", " + o.getAdr() + ", " + o.getLevel() , idleft, id);
                  		
                  		
               		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$2",58, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ConstDecl ::= CONST Type IDENT EQUALS CDD NT$1 SEMICOL 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int vright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		Integer v = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ConstDecl",8, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-6)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // NT$1 ::= 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-2)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		Integer v = (Integer)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;

                 		Obj o = parser.tabInsert(Obj.Con, id, t, tleft);
                 		
                 		o.setAdr( v );
                  		//parser.nice_print(" nadjeno Con {1} : " + currentTypeName.toString() +", " + o.getAdr() + ", " + o.getLevel() , idleft, id);
                  		
                  		
               		 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$1",57, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // MethodDeclList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // MethodDeclList ::= MethodDeclList MethodDecl 
            {
              Object RESULT =null;
		 defOfFunctionsInProgram++;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",3, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // Declaration ::= ClassDecl 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Declaration",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // Declaration ::= NT$0 VarDecl 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		 varDecIsGlobal = false; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Declaration",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // NT$0 ::= 
            {
              Object RESULT =null;
 varDecIsGlobal = true; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("NT$0",56, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // Declaration ::= ConstDecl 
            {
              Object RESULT =null;
		 globalConstants++; 
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Declaration",2, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // DeclarationList ::= 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclarationList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // DeclarationList ::= DeclarationList Declaration 
            {
              Object RESULT =null;

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("DeclarationList",1, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // ProgName ::= IDENT 
            {
              Obj RESULT =null;
		int pNameleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).left;
		int pNameright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()).right;
		String pName = (String)((java_cup.runtime.Symbol) CUP$MJParser$stack.peek()).value;
		  
	RESULT = Tab.insert(Obj.Prog, pName, Tab.noType);
	Tab.openScope(); 
	parser.nice_print(" pronadjeno ime programa: {1}.", pNameleft , pName);

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("ProgName",51, ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)).value;
		RESULT = start_val;
              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-1)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$MJParser$parser.done_parsing();
          return CUP$MJParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // Program ::= PROGRAM ProgName DeclarationList LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$MJParser$stack.elementAt(CUP$MJParser$top-4)).value;
		
	Tab.chainLocalSymbols(p);
	// Static data size
	Code.dataSize = Tab.currentScope().getnVars();
	Tab.closeScope(); 

              CUP$MJParser$result = parser.getSymbolFactory().newSymbol("Program",0, ((java_cup.runtime.Symbol)CUP$MJParser$stack.elementAt(CUP$MJParser$top-5)), ((java_cup.runtime.Symbol)CUP$MJParser$stack.peek()), RESULT);
            }
          return CUP$MJParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

